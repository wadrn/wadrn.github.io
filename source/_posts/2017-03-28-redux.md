---
title: react + redux
date: 2017-03-28
categories: 
- FE
- React
tags:
- FE
- React
- redux
---

# redux底层架构实现
Redux是一种架构模式

React-redux 就是把 Redux 这种架构模式和 React.js 结合起来的一个库

dispatch 专门负责数据修改,接受一个参数action.

action是一个普通的js对象，里面必须包含一个type字段来声明用来做什么操作。

原来模块（组件）修改共享数据是直接改的,这样无法把控。

通过dispatch，所有数据修改必须通过它，并且必须用action来声明你的操作，只有它允许才能修改.

有了如下这种集合：

```javascript
let appState = {
  title: {
    text: 'React.js 小书',
    color: 'red',
  },
  content: {
    text: 'React.js 小书内容',
    color: 'blue'
  }
}

function dispatch (action) {
  switch (action.type) {
    case 'UPDATE_TITLE_TEXT':
      appState.title.text = action.text
      break
    case 'UPDATE_TITLE_COLOR':
      appState.title.color = action.color
      break
    default:
      break
  }
}
```


把它们集中到一个地方，给这个地方起个名字叫做store，然后构建一个函数createStore，用来专门生产这种这种state和dispatch的集合，这样其他App也可以用这种模式了。


```javascript
function createStore(state,stateChanger){
const getState =()=>state;
const dispatch =(action)=>stateChanger(state,action);
return {getState,dispatch}
```


`createStore`接受两个参数，一个表示应用程序状态，另一个用来描述应用程序会根据`action`发生什么变化，相当于`dispatch`函数里面的内容。
`createStore`会返回一个对象，这个对象里面包含两个方法`getState`和`dispatch`。

```javascript
let appState = {
  title: {
    text: 'React.js 小书',
    color: 'red',
  },
  content: {
    text: 'React.js 小书内容',
    color: 'blue'
  }
}

function stateChanger (state, action) {
  switch (action.type) {
    case 'UPDATE_TITLE_TEXT':
      state.title.text = action.text
      break
    case 'UPDATE_TITLE_COLOR':
      state.title.color = action.color
      break
    default:
      break
  }
}

const store = createStore(appState, stateChanger)

renderApp(store.getState()) // 首次渲染页面
store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' }) // 修改标题文本
store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' }) // 修改标题颜色
renderApp(store.getState()) // 把新的数据渲染到页面上
```


针对每个不同的App，我们可以给`createStore`传入初始数据`appState` ，和一个描述数据变化的函数`stateChanger`，然后生成一个`store`，需要修改数据的时候通过`store.dispatch`,需要获取数据的时候通过`store.getState`

## 监控数据变化

如上代码，我们每次通过` dispatch` 修改数据的时候，其实只是数据发生了变化，如果我们不手动调用 `renderApp`，页面上的内容是不会发生变化的。但是我们总不能每次 `dispatch `的时候都手动调用一下 `renderApp`，我们肯定希望数据变化的时候程序能够智能一点地自动重新渲染数据，而不是手动调用。

你说这好办，往 `dispatch`里面加` renderApp `就好了，但是这样` createStore` 就不够通用了。我们希望用一种通用的方式“监听”数据变化，然后重新渲染页面，这里要用到***订阅者模式***。修改 createStore：


```javascript
function createStore (state, stateChanger) {
  const listeners = []
  const subscribe = (listener) => listeners.push(listener)
  const getState = () => state
  const dispatch = (action) => {
    stateChanger(state, action)
    listeners.forEach((listener) => listener())
  }
  return { getState, dispatch, subscribe }
}
```


我们在 `createStore` 里面定义了一个数组 `listeners`，还有一个新的方法 `subscribe`，可以通过 `store.subscribe(listener)` 的方式给 `subscribe` 传入一个监听函数，这个函数会被 push 到数组当中。

我们修改了 `dispatch`，每次当它被调用的时候，除了会调用` stateChanger` 进行数据的修改，还会遍历 `listeners` 数组里面的函数，然后一个个地去调用。相当于我们可以通过 `subscribe` 传入数据变化的监听函数，每当 dispatch 的时候，监听函数就会被调用，这样我们就可以在每当数据变化时候进行重新渲染：



```javascript
const store = createStore(appState, stateChanger)
store.subscribe(() => renderApp(store.getState()))

renderApp(store.getState()) // 首次渲染页面
store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' }) // 修改标题文本
store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' }) // 修改标题颜色
// ...后面不管如何 store.dispatch，都不需要重新调用 renderApp
```


现在我们有了一个比较通用的 `createStore`，它可以产生一种我们新定义的数据类型 `store`，通过 `store.getState` 我们获取共享状态，而且我们约定只能通过 `store.dispatch` 修改共享状态。`store` 也允许我们通过 `store.subscribe `监听数据数据状态被修改了，并且进行后续的例如重新渲染页面的操作。
我们接下来会继续优化我们的 `createStore `的模式，让它使我们的应用程序获得更好的性能。

## 共享结构的对象

ES6中有这样的语法；


```javascript
const obj ={a:1,b:2}
const obj2 = {...obj} //=>{a:1,b:2}
```


`const obj2 = { ...obj } `其实就是新建一个对象 `obj2`，然后把` obj `所有的属性都复制到 `obj2` 里面，相当于对象的浅复制。上面的 `obj` 里面的内容和 `obj2 `是完全一样的，但是却是两个**不同的**对象。除了浅复制对象，还可以覆盖、拓展对象属性：


```javascript
const obj = { a: 1, b: 2}
const obj2 = { ...obj, b: 3, c: 4} // => { a: 1, b: 3, c: 4 }，覆盖了 b，新增了 c
```


我们可以把这种特性应用在` state` 的更新上，我们禁止直接修改原来的对象，一旦你要修改某些东西，你就得把修改路径上的所有对象复制一遍，例如，我们不写下面的修改代码：
`appState.title.text = 'react'`
而是新建一个`appState`，新建`appState.title`，新建`appState.title.text`：

```javascript
let newAppState ={//新建一个newAppState
...appState,//复制appState里面的内容
title:{ // 用一个新的对象覆盖原来的 title 属性
  ...appState.title,// 复制原来 title 对象里面的内容
  text:'react'// 覆盖 text 属性
  }
}
```


`appState` 和 `newAppState` 其实是两个不同的对象，因为对象浅复制的缘故，其实它们里面的属性 `content `指向的是同一个对象；但是因为 `title `被一个新的对象覆盖了，所以它们的 `title `属性是不同的。
我们每次修改某些数据的时候，都不会碰原来的数据，而是把需要修改数据路径上的对象都 copy 一个出来。这样有什么好处？看看我们的目的达到了：


```javascript
appState !== newAppState // true，数据变化了，重新渲染
appState.title !== newAppState.title // true，数据变化了，重新渲染
appState.content !== appState.content // false，数据没有变化，不需要重新渲染
```

## 优化性能
修改`stateChanger`，让它修改数据的时候，并不会直接修改原来的数据 `state`，而是产生上述的共享结构的对象：

```javascript
function stateChanger (state, action) {
  switch (action.type) {
    case 'UPDATE_TITLE_TEXT':
      return { // 构建新的对象并且返回
        ...state,
        title: {
          ...state.title,
          text: action.text
        }
      }
    case 'UPDATE_TITLE_COLOR':
      return { // 构建新的对象并且返回
        ...state,
        title: {
          ...state.title,
          color: action.color
        }
      }
    default:
      return state // 没有修改，返回原来的对象
  }
}
```

每次需要修改的时候都会产生新的对象，并且返回。而如果没有修改（在 default 语句中）则返回原来的 state 对象。

因为` stateChanger` 不会修改原来对象了，而是返回对象，所以我们需要修改一下 `createStore`。让它用每次 `stateChanger(state, action) `的调用结果覆盖原来的 state：

```javascript
function createStore (state, stateChanger) {
  const listeners = []
  const subscribe = (listener) => listeners.push(listener)
  const getState = () => state
  const dispatch = (action) => {
    state = stateChanger(state, action) // 覆盖原对象
    listeners.forEach((listener) => listener())
  }
  return { getState, dispatch, subscribe }
}
```

再优化一下，其实` appState `和 `stateChanger` 可以合并到一起去：


```javascript
function stateChanger (state, action) {
  if (!state) {
    return {
      title: {
        text: 'React.js 小书',
        color: 'red',
      },
      content: {
        text: 'React.js 小书内容',
        color: 'blue'
      }
    }
  }
  switch (action.type) {
    case 'UPDATE_TITLE_TEXT':
      return {
        ...state,
        title: {
          ...state.title,
          text: action.text
        }
      }
    case 'UPDATE_TITLE_COLOR':
      return {
        ...state,
        title: {
          ...state.title,
          color: action.color
        }
      }
    default:
      return state
  }
}
```

`stateChanger` 现在既充当了获取初始化数据的功能，也充当了生成更新数据的功能。如果有传入 `state` 就生成更新数据，否则就是初始化数据。这样我们可以优化 `createStore `成一个参数，因为 `state` 和` stateChanger` 合并到一起了：

```javascript
function createStore (stateChanger) {
  let state = null
  const listeners = []
  const subscribe = (listener) => listeners.push(listener)
  const getState = () => state
  const dispatch = (action) => {
    state = stateChanger(state, action)
    listeners.forEach((listener) => listener())
  }
  dispatch({}) // 初始化 state
  return { getState, dispatch, subscribe }
}
```


我们给 stateChanger 这个玩意起一个通用的名字：`reducer`


## reducer
`createStore `接受一个叫 `reducer` 的函数作为参数，这个函数规定是一个纯函数，它接受两个参数，一个是 `state`，一个是 `action`。

如果没有传入` state `或者 `state `是 null，那么它就会返回一个初始化的数据。如果有传入 `state` 的话，就会根据 `action` 来“修改“数据，但其实它没有、也规定不能修改 state，而是要通过上节所说的把修改路径的对象都复制一遍，然后产生一个新的对象返回。如果它不能识别你的 `action`，它就不会产生新的数据，而是（在 default 内部）把 `state` 原封不动地返回。

`reducer` 是不允许有副作用的。你不能在里面操作 DOM，也不能发 Ajax 请求，更不能直接修改` state`，它要做的仅仅是 —— **初始化和计算新的` state`**。


## 总结
`createStore `现在可以直接拿来用了，套路就是：

```javascript
// 定一个 reducer
function reducer (state, action) {
  /* 初始化 state 和 switch case */
}

// 生成 store
const store = createStore(reducer)

// 监听数据变化重新渲染页面
store.subscribe(() => renderApp(store.getState()))

// 首次渲染页面
renderApp(store.getState()) 

// 后面可以随意 dispatch 了，页面自动更新
store.dispatch(...)
```



现在的代码跟 React.js 一点关系都没有，接下来我们要把 React.js 和 Redux 结合起来，用 Redux 模式帮助管理 React.js 的应用状态。
## react-redux
前端中应用的状态存在的问题：一个状态可能被多个组件依赖或者影响，而 React.js 并没有提供好的解决方案，我们只能把状态提升到依赖或者影响这个状态的所有组件的公共父组件上，我们把这种行为叫做状态提升。但是需求不停变化，共享状态没完没了地提升也不是办法。
后来我们在 React.js 的 context 中提出，我们可用把共享状态放到父组件的 context 上，这个父组件下所有的组件都可以从 context 中直接获取到状态而不需要一层层地进行传递了。但是直接从 context 里面存放、获取数据增强了组件的耦合性；并且所有组件都可以修改 context 里面的状态就像谁都可以修改共享状态一样，导致程序运行的不可预料。

既然这样，为什么不把 context 和 store 结合起来？毕竟 store 的数据不是谁都能修改，而是约定只能通过 dispatch 来进行修改，这样的话每个组件既可以去 context 里面获取 store 从而获取状态，又不用担心它们乱改数据了。


---
title: 动态规划算法
date: 2017-03-10
categories: 
- algorithm
tags:
- algorithm
- dp
---

## 动态规划算法

### 动态规划算法基本概念
动态规划的过程：每次决策依赖于当前状态，又随机引起状态的转移。一个决策序列就是在变化的状态中产生出来的，是一种多阶段最优化决策解决问题的过程。
### 基本思想
将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息，在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其它局部解。

### 实际问题
> #### 数字三角形
![数字三角形](http://img.blog.csdn.net/20150811133448624?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

 在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99。
输入格式：

    5      //表示三角形的行数    

    7

    3   8

    8   1   0

    2   7   4   4

    4   5   2   6   5

    要求输出最大和
    
#### 基本思路
用一个二期数组存放数字三角形
用D[i,j]表示第i行第j个数字（i 和j 均从1开始）
用MaxSum[i,j]表示从D[i,j]到底边的各条路径的和的最大值。
因此，问题改为求MaxSum[1,1];

-----
用递归解决,递归方程如下：
_MaxSum[i,j] = D[i,j]  i=N
MaxSum[i,j] = Max(MaxSum[i+1,j],MaxSum[i+1,j+1])+D[i,j] i!=N_
根据递归方程可得代码：

```
#include<iostream>
#include<Math.h>
using namespace std;
int D[101][101];
int n;
int MaxSum(int i,int j){
    if(i==n){
      return D[i,j];
    }
    return max(MaxSum[i+1,j],MaxSum[i+1,j+1)+D[i,j];
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
        cin >>D[i,j};
        }
        }
   cout<<MaxSum[1,1]<<endl;
   }
```
但是，这样计算的时间复杂度非常高，因为我们重复计算了很多次已经计算过的值。

![三角形计算值](http://img.blog.csdn.net/20150811140840233?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
**例如**：计算MaxSum[2,1]时，会计算MaxSum[3,2];当计算MaxSum[2,2]时，又会计算MaxSum[3,2]。这样就会重复很多次无用计算。
所以可以改进程序，使之成为 _记忆型递归算法_

```
#include<iostream>
#include<Math.h>
using namespace std;
int D[101][101];
int n;
int MaxSum(int i,int j){
    if(MaxSum[i,j]!=-1){
      return MaxSum[i,j];
    }
    if(i==n){
      return D[i,j];
    }
    return max(MaxSum[i+1,j],MaxSum[i+1,j+1)+D[i,j];
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
        cin >>D[i,j};
        MaxSum[i,j]=-1;
        }
        }
    cout<<MaxSum[1,1]<<endl;
   }
```
因为递归要使用大量堆栈空间，容易造成栈溢出，所以考虑把递归改为递推。
从最后一行开始计算，因为最后一行的值可以直接得到：
![](http://img.blog.csdn.net/20150811152746815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
然后倒数第二行，从左侧第一个数开始，将其与下方左右两个数分别相加，选择最大的填入空格。
![](http://img.blog.csdn.net/20150811153237686?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
依次计算每行的值
![](http://img.blog.csdn.net/20150811153534629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
![](http://img.blog.csdn.net/20150811153553012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
由此，便从递归型动态规划=>递推型动态规划：

```
#include<iostream>
#include<stdio.h>
using namespace std;
int D[101][101];
int MaxSum[101][101];
int n;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            cin>>D[i,j];
        }
    }
    for(int i=1;i<=n;i++){
        MaxSum[n][i] = D[n][i];
    }
    for(int i=n-1;i>=1;i--){
        for(int j=1;j<=i,;j++){
            MaxSum[i][j]=max(MaxSum[i+1][j],MaxSum[i+1][j+1])+D[i][j];
       }
     }
     cout<<MaxSum[1][1]<<endl;  
```
接下来对空间进行优化，可以不采用二维数组来存储MaxSum[i][j],只要采用一维数组MaxSum[101]，一层一层向外推就可以了。
对空间优化后的递推过程如下：
![](http://img.blog.csdn.net/20150811155011262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
![](http://img.blog.csdn.net/20150811155028144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
![](http://img.blog.csdn.net/20150811155119121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
![](http://img.blog.csdn.net/20150811155136507?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
![](http://img.blog.csdn.net/20150811155255355?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
![](http://img.blog.csdn.net/20150811155311499?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
maxSum数组都可以不要，直接用D的第n行直接替代maxSum即可

```
#include <iostream>  
#include <algorithm> 
using namespace std; 

#define MAX 101  

int D[MAX][MAX];  
int n; 
int * maxSum; 

int main(){    
	int i,j;    
	cin >> n;    
	for(i=1;i<=n;i++)   
		for(j=1;j<=i;j++)        
			cin >> D[i][j];   
	maxSum = D[n]; //maxSum指向第n行    
	for( int i = n-1; i>= 1;  --i )     
		for( int j = 1; j <= i; ++j )       
			maxSum[j] = max(maxSum[j],maxSum[j+1]) + D[i][j];    
	cout << maxSum[1] << endl;  
}
```
### 动态规划适用情况
一般具有三个性质：
1. **最优化原理**：问题的最优解所包含的子问题的解也是最优的，称该问题具有最优子结构。
2. **无后效性**：某阶段状态一旦确定，就不受这个状态以后的决策的影响。
3. **有重叠子问题**：子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用。（不是必要条件）。

### 求解的基本步骤
1. *化分阶段*：化分后的阶段一定要是有序的或者是可排序的。
2. *确定状态和状态变量*：将问题发展到各个阶段时所处的各种客观情况用不同的状态表示出来。
3. *确定决策并写出状态转移方程*：状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。
4. *寻找边界条件*：状态转移方程是一个递推式，需要递推的终止条件。

f(n,m)=max{f(n-1.m),f(n-1,m-w[n])+P(n,m)};

-----
最后提供一个非常全面的动态规划讲解：
作者：Hawstein
出处：[http://www.hawstein.com/posts/dp-novice-to-advanced.html]()
声明：本文采用以下协议进行授权： 自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0 ，转载请注明作者及出处。


---
title: React高阶组件
date: 2018-09-23
categories: 
- FE
- React
tags:
- React
---

# 什么是高阶组件

高阶组件只是**包装**了另外一个React组件的React组件

高阶组件主要有两种方式来实现：

1. 属性代理

高阶组件操控传递给wrappedComponent的props

2. 反向继承

高阶组件继承 wrappedComponent
<!-- more -->
# 高阶组件用来做什么

1. 代码复用，逻辑抽象，抽离底层
2. 渲染劫持
3. state 抽象和更改
4. props更改

# 高阶组件的实现方式

## Props Proxy

```javascript
function ppHOC(wrappedComponent){
    return class PP extends React.Component{
        render(){
            return <wrappedComponent {...this.props}/>
        }
    }
}
```

可以看到，这里高阶组件的 render 方法返回了一个 type wrappedComponent 的 React Element（也就是被包装的那个组件），我们把高阶组件收到的 props 传递给它，因此得名 Props Proxy。

### Props Proxy 可以做什么

#### 更改 props

```javascript
function ppHOC(WrappedComponent) {
  return class PP extends React.Component {
    render() {
      const newProps = {
        user: currentLoggedInUser
      }
      return <WrappedComponent {...this.props} {...newProps}/>
    }
  }
}
```

#### 通过 refs 获取组件实例

你可以通过 ref 获取关键词 this（WrappedComponent 的实例），但是想要它生效，必须先经历一次正常的渲染过程来让 ref 得到计算，这意味着你需要在高阶组件的 render 方法中返回 WrappedComponent，让 React 进行 reconciliation 过程，这之后你就通过 ref 获取到这个 WrappedComponent 的实例了。

```javascript
function refsHOC(WrappedComponent) {
  return class RefsHOC extends React.Component {
    proc(wrappedComponentInstance) {
      wrappedComponentInstance.method()
    }
    render() {
      const props = Object.assign({}, this.props, {ref: this.proc.bind(this)})
      return <WrappedComponent {...props}/>
    }
  }
}
```

#### 抽象 state

#### 把wrappedComponent与其他elements包装在一起

## Inheritance Inversion

```javascript
function iiHOC(WrappedComponent) {
  return class Enhancer extends WrappedComponent {
    render() {
      return super.render()
    }
  }
}

```
返回的高阶组件类（Enhancer）继承了 WrappedComponent。这被叫做反向继承是因为 WrappedComponent 被动地被 Enhancer 继承，而不是 WrappedComponent 去继承 Enhancer。通过这种方式他们之间的关系倒转了。

反向继承允许高阶组件通过 this 关键词获取 WrappedComponent，意味着它可以获取到 state，props，组件生命周期（component lifecycle）钩子，以及渲染方法（render）。

我不会详细介绍你可以使用组件生命周期方法做什么，因为这是 React 的内容，而不是高阶组件的。但是请注意，你可以通过高阶组件来给 WrappedComponent 创建新的生命周期挂钩方法，别忘了调用 super.[lifecycleHook] 防止破坏 WrappedComponent。

### Inheritance Inversion 可以做什么

#### 渲染劫持

叫做渲染劫持是因为高阶组件控制了 WrappedComponent 生成的渲染结果，并且可以做各种操作。
通过渲染劫持你可以：

『读取、添加、修改、删除』任何一个将被渲染的 React Element 的 props
在渲染方法中读取或更改 React Elements tree，也就是 WrappedComponent 的 children
根据条件不同，选择性的渲染子树
给子树里的元素变更样式
*渲染 指的是 WrappedComponent.render 方法

#### 操作state

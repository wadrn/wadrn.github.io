---
title: Next Permutation
date: 2017-03-07
categories: 
- Leetcode
tags:
- Leetcode
- 笔试题
---

## 下一个字典序 Next Permutation
### leetcode 31
题目描述：Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).
The replacement must be in-place, do not allocate extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.
1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1

-------

### 算法分析
交换+逆序
1. 从后向前遍历直到遇到第一对正序对，num[i]>num[i+1];
2. 从后向前遍历找到第一个大于num[i]的数字，num[i]<num[j];
3. 交换num[i]和num[j];
4. 将num[i+1]~num[length-1]逆序排列
### 代码（js）

```javascript
var nextPermutation = function(nums) {
    var len=nums.length;
    if(len<=1){
        return;
    }
    /*第一个正序对的i值*/
    var cur=-1;   
    for(var i=len-2;i>=0;i--){
        if(nums[i]<nums[i+1]){
            cur=i;
            break;
        }
    }
    /*若不存在，则重新最小排序*/
    if(cur===-1){
        nums.sort(function(a,b){
            return a-b;
        });
    /*存在则从后向前遍历找到第一个j使得num[j]>num[cur]*/
    }else{
        var greater;
        for(var j=len-1;j>cur;j--){
            if(nums[j]>nums[cur]){
                greater=j;
                break;
            }
        }
        /*交换num[i]和num[j]*/
        var tmp=nums[greater];
        nums[greater]=nums[cur];
        nums[cur]=tmp;
        
        /*逆序num[i+1]~num[len-1]*/
        var num= nums.splice(cur+1,len-cur-1);
        num.reverse();
        Array.prototype.push.apply(nums,num);
    }
};
```

-------
### 遇到的问题
将数组num[i+1]~num[length-1]逆序排列，因为本题无返回值，所以只能在原有数组上进行操作，开始的方法是：

```javascript
var num = nums.splice(cur+1,len-cur-1);
num.reverse();
nums = nums.concat(num);
```

但是提交之后发现concat函数无效，因此改用

```javascript
Array.prototype.push.apply(nums,num)
```

因为向数组添加数组所以不能直接用

```javascript
nums.push()
```

### 延伸---全排列算法
#### 全排列就是从最小字典序排列到最大字典序的过程
#### 算法
1. 对给定的序列作升序排列，得到最小字典序
2. 对有序排列求下一个字典序
3. 若当前排序没有下一个字典序，即已经得到最大字典序，全排列结束。

当然还有很多其他全排列算法，例如递归：
当n=1时，perm（R）=（r），其中r是集合R中唯一元素。
当n>1时，perm（R）由（r1）perm（R1），（r2）perm（R2），....，（rn）perm（Rn）构成。



---
title: js设计模式与开发实践(一)
date: 2018-03-25
categories: 
- FE
tags:
- FE
- 设计模式
---

# 闭包和高阶函数

## 闭包
### 变量的作用域

### 变量的生存周期

一个内部变量在暴露给外部的空间使用，使得该变量还有存在的价值，就不会被销毁。
### 闭包的更多作用

1. 封装变量

把一些不需要暴露在全局的变量封装成“私有变量”。

2. 延续局部变量的寿命

封装起来，返回能访问到的函数。
## 高阶函数

至少满足下列条件之一的函数:
1. 函数可以作为参数传递
2. 函数可以作为返回值输出


### 函数作为参数传递

可以抽离一部分容易变化的逻辑，把这部分逻辑放在函数参数中，可以分离业务代码种变化与不变的部分。 （**回调函数**）

ajax异步请求 

当一个函数适合执行一些请求时，可以把这些请求封装成一个函数，并把它作为参数传递给另外一个函数，委托给另外一个函数来执行。

委托的方法来确定执行的时机

逻辑关系不紧密的部分，抽离出来，不要耦合太高

### 函数作为返回值输出

让函数继续返回一个可执行的函数，意味着运算过程是可延续的

1. 判断数据的类型


2. 高阶函数实现AOP
AOP 面向切面编程 主要作用是把一些跟核心业务逻辑模块无关的功能抽象出来，包括日志统计，安全控制，异常处理。


装饰者模式

#### 常见的高阶函数

##### currying

会首先接收一些参数，但不会求值，会返回一个函数，这个函数将这些参数用闭包封闭起来，待到需要求值的时候，所有参数会一次性求值。

```javascript

```
##### uncurrying

反科里化就是 ，扩大适用范围，创建一个应用范围更广的函数，把泛化this的过程提出来。

this.method  ===>  method(this,arg1,arg2....)
实现this泛化

```javascript

Function .prototype.uncurrying = function(){
    var self = this;
    return function(){
        var obj = Array.prototype.shift.call(arguments);
        return self.apply(obj,arguments);
    }
}


var push = Array.prototype.push.uncurrying();

(function(){
    push(arguments,4);
    console.log(arguments) // 1,2,3,4
})(1,2,3);

var arr = ['push','shift','forEach'];
for(var i=0;i<ary.length;i++){
    var fn = arr[i];
    Array[fn] = Array.prototype[fn].uncurrying();
}
var obj = {
    'length':3,
    "0":1,
    "1":2,
    "2":3
};
Array.push(obj,4);


Function.prototype.uncurrying = function(){
    var self = this;
    return function(){
        return Function.prototype.call.apply(self,arguments);
    }
}
```

##### 函数节流

函数节流 主要解决 函数的触发不是由用户直接控制的，在某些场景下，函数有可能被非常频繁地调用，造成性能问题。

主要出现在一下场景中：
1. window.onresize
2. mousemove 事件
3. 上传进度

>将即将被执行的函数用setTimeout延迟一段时间执行，如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求。
接收两个参数：函数、延迟时间

```javascript
var throttle = function(fn,delay){
    var timer;
    var firsttime = true;  //是否是第一次调用
    return function(){
        var args = arguments;
        var _this = this;
        if(firsttime){
            fn.apply(_this,args);
        }else{
            if(timer){
                return false;
            }
            timer = setTimeout(function(){
                clearTimeout(timer);
                timer = null;
                fn.apply(_this,args);
            },delay);
        };
    };
}

var throttle = function(fn,delay,interval){
    var timer = null;
    var pre = null;
    return function(){
        var now = +new Date();
        var args = arguments;
        if(!pre){
            pre = now;
        }
        var remain = now - pre;
        if(interval && remain >=interval){
            fn.apply(null,args);
            pre = now;
        }else{
            clearTimeout(timer);
            timer = setTimeout(function(){
                fn.apply(null,args);
            },delay);
        }
    }
}


window.onscroll = throttle(fn,500,2000);

var time = +new Date();

var fn = function(){
    console.log("函数调用"+(+new Date()-time));
}

```

##### 分时函数

某些函数确实是用户主动调用的，但因为一些客观原因，这些函数会严重影响页面性能。
eg. 创建WebQQ的qq好友列表，如果一个好友用一个节点来表示，当在页面渲染这个列表的时候，可能要一次性往页面中创建成百上千个节点。

解决方法    =====>    timeChunk函数 （分时函数）
timeChunk 可以让创建节点的工作**分批进行**，比如把1秒创建1000个节点，改为每隔200ms创建8个节点

```javascript
var timeChunk  = function(arr,fn,cnt,interval){
    var obj ,timer;
    var len = arr.length;
    var start = function(){
        for(var i=0;i < Math.min(cnt || 1,arr.length);i++){
            var obj = arr.shift();
            fn(obj);
        }
    };
    return function(){
        timer = setInterval(function(){
            if(arr.length == 0){
                return clearInterval(timer);
            }
            start();
        },interval);
    }
}
```

##### 惰性加载函数

嗅探函数

1. 将嗅探浏览器的操作提前到代码加载的时候，在代码加载的时候就立刻进行一次判断，以便让addEvent返回一个包裹了正确逻辑的函数。

```javascript
var addEvent = (function(){
    if(window.addEventListener){
        return function(ele,type,handler){
            ele.addEventListener(type,handler,false);
        }
    }
    if(window.attachEvent){
        return function(ele,type,handler){
            ele.attachEvent('on'+type,handler);
        }
    }
})()

```

但是如果没有使用过这个函数可能会导致多余的操作，也许会稍稍延长页面ready的时间，所以加入惰性载入方案。

**在第一次进入条件分支之后，在函数  ‘内部重写’ 这个函数，重写之后函数就是我们期望的addEvent函数，在下次进入的时候，不再存在条件分支语句。**

```javascript
var addEvent = function(ele,type,handler){
    if(window.addEventListener){
        addEvent = function(ele,type,handler){
            ele.addEventListener(type,handler,false);
        }
    }else if(window.attachEvent){
        addEvent = function(ele,type,handler){
            ele.attachEvent('on'+type,handler);
        }
    }
    addEvent(ele,type,handler);
}
```





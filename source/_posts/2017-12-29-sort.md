---
title: 排序算法
date: 2017-12-29
categories: 
- Algorithm
tags:
- sort
---

元旦放假前的最后一天啦

还是要好好学习的啦~~

# 选择排序

## 特点：
1. 运行时间和输入无关 与初始状态无关
2. 数据移动是最少的
3. 不稳定排序（举个例子：序列5 8 5 2 9， 我们知道第一趟选择第1个元素5会与2进行交换，那么原序列中两个5的相对先后顺序也就被破坏了。）



```javascript
//选择排序
var selectSort  = function(arr){
  for(var i=0;i<arr.length;i++){
    var min_Index = i;
    for(var j=i+1;j<arr.length;j++){
      min_Index = arr[min_Index] <arr[j]?min_Index:j;
    }
    console.log(min_Index);
    if(min_Index != i ){
      swap(arr,i,min_Index);
    }
  }
  return arr;
}
var swap = function(arr,i,j){
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
```

# 插入排序

1. 时间取决于输入中元素的初始排序
2. 在有序数组中效率最高 O(n)
3. 稳定排序

```javascript
//插入排序
var insertSort  = function(){
  for(var i=0;i<arr.length;i++){
    var item = arr[i];
    for(var j=i-1;j>=0;j--){
      if(arr[j]>item){
        arr[j+1] = arr[j]; 
      }else{
        break;
      }
    }
    arr[j+1] = item;
  }
  return arr;
}
```

# 希尔排序

1. 插入排序的变形，将数组先转化成h有序的数组
2. 不稳定排序

```javascript
//希尔排序
var swap = function(arr,i,j){
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
var xierSort = function(arr){
  var h =1;
  var n = arr.length;
  while(h < n/3){
    h =h*3+1;
  }
  while(h>=1){
    for(var i=h;i<n;i++){
      for(var j=i;j>=h;j-=h){
        if(arr[j] < arr[j-h]){
          swap(arr,j,j-h);
        }
      }
    }
    h = parseInt(h/3);
  }
  return arr;
}
```
# 归并排序

1. 稳定排序


```javascript
//归并排序

var guibinSort = function(arr){
  sort(arr,0,arr.length-1);
  return arr;
}
var sort = function(arr,low,high){
  if(high <=low){
    return;
  }
  var mid = parseInt((low+high)/2);
  sort(arr,0,mid);
  sort(arr,mid+1,high);
  merge(arr,low,mid,high);
  console.log(arr)
}
var merge = function(arr,low,mid,high){
  var aux = arr.slice();
  var i= low,j= mid+1;
  for(var k=low;k<=high;k++){
    if(i>mid){
      arr[k] = aux[j++];
    }else if(j>high){
      arr[k] = aux[i++];
    }else if(aux[j]<aux[i]){
      arr[k] = aux[j++];
    }else{
      arr[k] = aux[i++];
    }
  }
}
```
# 快速排序

1. 这是平均查找效率很高的排序
2. 不稳定排序
（比如序列为 5 3 3 4 3 8 9 10 11 
现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱。
所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j]交换的时刻。)

```javascript
//快速排序

var quickSort = function(arr){
  sort(arr,0,arr.length-1);
  return arr;
}
var sort = function(arr,low,high){
   if(high <=low){
    return;
  }
  var j = partition(arr,low,high);
  sort(arr,low,j-1);
  sort(arr,j+1,high);
}
var partition = function(arr,low,high){
  var pivot = arr[low];
  var i=low
  var j=high+1;
  while(true){
    while(arr[++i] <pivot){
      if(i==high){
        break;
      }
    }
    while(pivot <arr[--j]){
      if(j==low){
        break;
      }
    }
    if(i>=j){
      break;
    }
    swap(arr,i,j);
  }
  swap(arr,low,j);
  return j;
}
var swap = function(arr,i,j){
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
```
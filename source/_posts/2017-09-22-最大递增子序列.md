---
title: 最大递增子序列
date: 2017-09-22
categories: 
- Leetcode
tags:
- Leetcode
- 笔试题
---

### 最大递增子序列问题
算法原型
1. 第一种方法：
时间复杂度O(n^2)


2. 第二种方法：

时间复杂度O(nlogn)的算法，（需要额外数组H）
H(i)代表的意义：
遍历到当前时刻为止，长度为i+1的最长递增子序列的最小末尾是多少
找第一个比当前值大的值（二分法）
n表示以当前数字结尾的最大子序列
 eg. arr=[2,1,6,4,5,2,7,4]
 i=0时，arr[0]=2,H[0]=2;H=[2],有效区=1 n=1
 i=1时，arr[1]=1,2>1,H[0]=1;H=[1],有效区=1 n=1
 i=2时，arr[2]=6,H中没有比6大的值，[1]=6,H=[1,6],有效区=2 n=2
 i=3时，arr[3]=4,6>4,H[1]=4,H=[1,4],有效区=2   n=2
 i=4时，arr[4]=5,H中没有比5大的值，H[2]=5,H=[1,4,5],有效区=3 n=3
i=5时，arr[5]=2,4>2,H[1]=2,H=[1,2,5] n=2
 i=6时，arr[6]=7,H中没有比7大的值，H[3]=7,H=[1,2,5,7],有效区=4  n=4
 i=7时，arr[7]=4,5>4,H[2]=4,H=[1,2,4,7],有效区=4  n=3

### 沙皇问题

**最大递增子序列对**
时间复杂度：O(nlogn)
算法原型同上
先按照a的值从小到大排序，在a的值相同的情况下，再按照b的值从小到大排序
H数组中只存储b出现的最小末尾

```javascript
var maxEnvelopes = function(envelopes) {
    if(envelopes.length ===0 ||envelopes.length ===1){
        return envelopes.length;
    }
    var Comparator = function(a,b){
        if(a[0]<b[0]){
            return -1;
        }else if(a[0]>b[0]){
            return 1;
        }else{
            if(a[1]<b[1]){
                return 1;
            }else if(a[1]>b[1]){
                return -1
            }else{
                return 0;
            }
        }
    }
    envelopes.sort(Comparator);
    var dp=[];
    var ends=[];
    dp[0]=envelopes[0][1];
    ends[0]=envelopes[0][1];
    var result=0;
    var l=0;
    var r=0;
    var valid=0;
    var m;
    for(var i=0;i<envelopes.length;i++){
        l=0;
        r=valid;
        while(l<=r){
            m=parseInt((l+r)/2);
            if(envelopes[i][1]>ends[m]){
                l=m+1;
            }else{
                r=m-1;
            }
        }
        valid = Math.max(valid,l);
        ends[l]=envelopes[i][1];
        dp[i]=l+1;
    }
    for(i in dp){
        result = Math.max(result,dp[i]);
    }
    return result;
};
```



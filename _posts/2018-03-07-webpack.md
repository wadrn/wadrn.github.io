---
title: webpack
date: 2018-03-07
categories: 
- FE
- webpack
tags:
- FE
---

# webpack

# 概念

 webpack 是一个 js应用程序 的静态模块打包器，当webpack处理应用程序时，会递归的构建一个依赖关系图。

 在 webpack.config.js 文件中

## entry

 ```javascript
 /*单个入口语法*/
 module.exports = {
  entry: './path/to/my/entry/file.js'
};
```
```javascript
/*对象语法*/
const config = {
  entry: {
    app: './src/app.js',    
    vendors: './src/vendors.js'  //第三方库
  }
};
```

这种属于 **分离应用程序和第三方库入口**
从表面上看，这告诉我们 webpack 从 app.js 和 vendors.js 开始创建依赖图(dependency graph)。这些依赖图是彼此完全分离、互相独立的（每个 bundle 中都有一个 webpack 引导(bootstrap)）。这种方式比较常见于，只有一个入口起点（不包括 vendor）的单页应用程序(single page application)中。

此设置允许你使用 CommonsChunkPlugin 从「应用程序 bundle」中提取 vendor 引用(vendor reference) 到 vendor bundle，并把引用 vendor 的部分替换为 __webpack_require__() 调用。如果应用程序 bundle 中没有 vendor 代码，那么你可以在 webpack 中实现被称为长效缓存的通用模式。

```javascript
/*多页面应用程序*/
const config = {
  entry: {
    pageOne: './src/pageOne/index.js',
    pageTwo: './src/pageTwo/index.js',
    pageThree: './src/pageThree/index.js'
  }
};
```
我们告诉 webpack 需要 3 个独立分离的依赖图

在多页应用中，（译注：每当页面跳转时）服务器将为你获取一个新的 HTML 文档。页面重新加载新文档，并且资源被重新下载。然而，这给了我们特殊的机会去做很多事：


## output

 配置 output 选项可以控制 webpack 如何向硬盘写入编译文件。注意，即使可以存在多个入口起点，但只指定一个输出配置。

 ```javascript

 const path = require('path');

module.exports = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  }
};

/*多个入口起点*/
{
  entry: {
    app: './src/app.js',
    search: './src/search.js'
  },
  output: {
    filename: '[name].js',
    path: __dirname + '/dist'
  }
}
// 写入到硬盘：./dist/app.js, ./dist/search.js
```

## loader

loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。

在更高层面，在 webpack 的配置中 loader 有两个目标：

1. test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。
2. use 属性，表示进行转换时，应该使用哪个 loader。

```javascript
const path = require('path');

const config = {
  entry: './path/to/my/entry/file.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: 'my-first-webpack.bundle.js'
  },
  module: {
    rules: [
      { test: /\.txt$/, use: 'raw-loader' }
    ]
  }
};

module.exports = config;
```
### loader特性

* loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照相反的顺序执行。
* loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。
* loader 可以是同步的，也可以是异步的。
* loader 运行在 Node.js 中，并且能够执行任何可能的操作。
* loader 接收查询参数。用于对 loader 传递配置。
* loader 也能够使用 options 对象进行配置。
* 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。
* 插件(plugin)可以为 loader 带来更多特性。
* loader 能够产生额外的任意文件。

## plugins

loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。

想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建它的一个实例。

webpack 插件是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。


```javascript
plugins: [
    new webpack.optimize.UglifyJsPlugin(),
    new HtmlWebpackPlugin({template: './src/index.html'})
  ]
  ```
## modules

在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为模块。

每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。

对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系，几个例子如下：

* ES2015 import 语句
* CommonJS require() 语句
* AMD define 和 require 语句
* css/sass/less 文件中的 @import 语句。
* 样式(url(...))或 HTML 文件(<img src=...>)中的图片链接(image url)

### 模块解析

resolver 是一个库(library)，用于帮助找到模块的绝对路径。一个模块可以作为另一个模块的依赖模块，然后被后者引用，如下：
```javascript
import foo from 'path/to/module'
// 或者
require('path/to/module')
```

## 模块热替换 （Hot Module Replacement HMR）

通过以下步骤，可以做到在应用程序中置换(swap in and out)模块：

1. 应用程序代码要求 HMR runtime 检查更新。
2. HMR runtime（异步）下载更新，然后通知应用程序代码。
3. 应用程序代码要求 HMR runtime 应用更新。
4. HMR runtime（异步）应用更新。
你可以设置 HMR，以使此进程自动触发更新，或者你可以选择要求在用户交互时进行更新。

## webpack热加载原理

基本实现原理大致这样的，构建 bundle 的时候，加入一段 HMR runtime 的 js 和一段和服务沟通的 js 。文件修改会触发 webpack 重新构建，服务器通过向浏览器发送更新消息，浏览器通过 jsonp 拉取更新的模块文件，jsonp 回调触发模块热替换逻辑。

热加载基本思路一般是很简单的，监听本地文件修改，然后服务器推送到客户端，执行更新即可。


* Code Splitting
* Everything is a module

所谓的 Code Splitting 不仅仅是把代码拆分成不同的模块，而是在代码中需要执行到的时候按需加载。这和纯前端 loader(比如 seajs、requirejs) 类似，但在 webpack 对模块设计上就区分了异步模块和同步模块，构建过程中自动构建成两个不同的 chunk 文件，异步模块按需加载。这一点突破是传统的 gulp 或者纯前端 loader 都无法做到的。

Code Splitting 还体现在对公共依赖的抽离(CommonsChunkPlugin)，如果一个构成过程有多入口文件，这些入口的公共依赖可以单独打包成一个 chunk 。

webpack 通过的 `require.ensure` 来定义一个分离点。`require.ensure` 在实际执行过程是触发了一个 jsonp 请求，这个请求回调后返回一个对象，这个对象包括了所有异步模块 id 与异步模块代码。


热加载实现主要分为几部分功能

服务器构建、推送更新消息
浏览器模块更新
模块更新后页面渲染


### 构建

热加载是通过内置的 HotModuleReplacementPlugin 实现的，构建过程中热加载相关的逻辑都在这个插件中。这个插件主要处理两部分逻辑

注入 HMR runtime 逻辑
找到修改的模块，生成一个补丁 js 文件和更新描述 json 文件

HMR runtime 主要定义了 jsonp callback 方法，这个方法会触发模块更新，并且对模块新增一个 module.hot 相关 API ，这个 API 可以让开发者自定义页面更新逻辑。

### 服务器推送

文件更新后，首先需要打包好新的补丁文件，还需要告诉浏览器文件修改了，可以拉代码了。

这一部分 webpack 自带了一个 dev-server。当开启热加载的时候，webpack-dev-server 会响应客户端发起的 EventStream 请求，然后保持请求不断开。这样服务器就可以在有更新的时候直接把结果 push 到浏览器。

服务器推送部分比较简单，构建一个 node 的 Server-Sent Events 服务器只需要几行代码，这里有一个例子。

一次完成的构建流程大概是这样的

https://zos.alipayobjects.com/rmsportal/MrLNdSjTeZJdtvczOalS.svg

对于基于 React 的应用，实现 React 热加载的基本思路分为两种

直接基于 module.hot API
对每个组件进行一次包裹，组件更新后替换原有组件原型上的 render 方法和其他方法


## webpack构建流程

从启动webpack构建到输出结果经历了一系列过程，它们是：

解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。

注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。

从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。

在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。

递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。

输出所有chunk到文件系统。
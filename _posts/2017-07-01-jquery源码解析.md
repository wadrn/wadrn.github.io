---
title: Jquery源码解析
date: 2017-07-01
categories: 
- FE
- jquery
- source code analysis
tags:
- FE
- jquery
---


# jquery源码解析
ps :smile: 想把这个写成一个系列解析的文章，督促自己每天学一下 :smile:


匿名函数没有函数名的函数，不存在外部引用
jQuery使用()将匿名函数括起来，然后后面再加一对小括号（包含参数列表），那么这小括号能把我们的表达式组合分块，并且每一块（也就是每一对小括号），都有一个返回值。这个返回值实际上也就是小括号中表达式的返回值。所以，当我们用一对小括号把匿名函数括起来的时候，实际上小括号返回的，就是一个匿名函数的Function对象。因此，小括号对加上匿名函数就如同有名字的函数般被我们取得它的引用位置了。所以如果在这个引用变量后面再加上参数列表，就会实现普通函数的调用形式。

### 加载时立即初始化

```javascript
if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ?
        factory(global, true) :
        function(w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
    };
} else {
    factory(global);
}
```


### 变量提升，函数声明可以进行变量提升，函数表达式不能进行变量提升
三种文档加载方式：

```javascript
$(document).ready(function() {
    // ...代码...
})
//document ready 简写
$(function() {
    // ...代码...
})
$(document).load(function() {
    // ...代码...
})
```
###DOM文档加载步骤

(1) 解析HTML结构。
(2) 加载外部脚本和样式表文件。
(3) 解析并执行脚本代码。
(4) 构造HTML DOM模型。//ready
(5) 加载图片等外部文件。
(6) 页面加载完毕。//load

ready和load的区别就在于 资源文件的加载
高级的浏览器，可以用DOMContentLoaded

```javascript
document.attachEvent( "onreadystatechange", completed );
window.attachEvent( "onload", completed );
var top = false;
try {
    top = window.frameElement == null && document.documentElement;
} catch(e) {}
if ( top && top.doScroll ) {
    (function doScrollCheck() {
        if ( !jQuery.isReady ) {
            try {
                top.doScroll("left");
            } catch(e) {
                return setTimeout( doScrollCheck, 50 );
            }
            detach();
            jQuery.ready();
        }
    })();
}
```

原理就是对于 IE 在非 iframe 内时，只有不断地通过能否执行 doScroll 判断 DOM 是否加载完毕。在上述中间隔 50 毫秒尝试去执行 doScroll，注意，由于页面没有加载完成的时候，调用 doScroll 会导致异常，所以使用了 try -catch 来捕获异常。
结论：所以总的来说当页面 DOM 未加载完成时，调用 doScroll 方法时，会产生异常。那么我们反过来用，如果不异常，那么就是页面DOM加载完毕了。

### jQuery多库共存处理
noConflict函数
$.onConflict()

### 分离构造器
通过new操作符构建一个对象：
1. 创建一个新对象
2. 将构造函数的作用域赋给新对象（this就指向了新对象）
3. 执行构造函数中的代码
4. 返回这个新对象
new操作符主要把原型链和实例的this关联起来。

```javascript
var $$=ajQuery =function(selector){
    this.selector = selector;
    return this;
}
ajQuery.fn = ajQuery.prototype = {
    selectorName:function(){
        return this.selector;
    },
    constructor:ajQuery
}
var a = new $$('aaa');
a.selectorName();
//另一种
var $$ = ajQuery = function(selector){
     if(!this instanceof ajQuery){
        return new ajQuery(selector);
    }
    this.selector =selector;
    return this;
}
```
###方法链式调用的实现



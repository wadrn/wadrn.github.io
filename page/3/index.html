<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="this  is a personal recordings for study &amp; life">
<meta property="og:type" content="website">
<meta property="og:title" content="Doreen&#39;s Notes">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Doreen&#39;s Notes">
<meta property="og:description" content="this  is a personal recordings for study &amp; life">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Doreen">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>Doreen's Notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Doreen's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/05/2017-04-05-react-router/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doreen">
      <meta itemprop="description" content="this  is a personal recordings for study & life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Doreen's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/05/2017-04-05-react-router/" class="post-title-link" itemprop="url">react router</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-04-05 00:00:00" itemprop="dateCreated datePublished" datetime="2017-04-05T00:00:00+08:00">2017-04-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-04 16:47:10" itemprop="dateModified" datetime="2022-05-04T16:47:10+08:00">2022-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index"><span itemprop="name">FE</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="React-Router"><a href="#React-Router" class="headerlink" title="React-Router"></a>React-Router</h1><p>路由本质就是嵌套的视图组件</p>
<h3 id="browserHistory"><a href="#browserHistory" class="headerlink" title="browserHistory"></a>browserHistory</h3><p><strong>功能</strong>：监听浏览器地址栏的变化，解析URL并与路由组件进行匹配。还提供了一些方法让你在代码中进行导航。<br>//跳转到某个路径<br><code>browserHistory.push(&#39;./some.path&#39;);</code><br>//回退到先前的地址<br><code>browserHistory.goBack()</code></p>
<h3 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h3><p>配置路由匹配信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>()=&gt;(</span><br><span class="line">  &lt;Route path=<span class="string">'/'</span> component=&#123;Main&#125;&gt;</span><br><span class="line">    &lt;IndexRoute component=&#123;Home&#125;/&gt;</span><br><span class="line">    &lt;Route path=<span class="string">'counter'</span> component=&#123;Counter&#125;/&gt;</span><br><span class="line"> &lt;<span class="regexp">/Route&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过上面的配置，程序知道如何渲染这些URL:</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>Components</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>Main-&gt;Home</td>
</tr>
<tr>
<td>/counter</td>
<td>Main-&gt;Counter</td>
</tr>
</tbody></table>
<p>使用了嵌套路由的概念<br>IndexRoute组件将作为父级Route的默认子路由组件，即为URL为/时显示的组件。</p>
<h3 id="使用Link和IndexLink导航"><a href="#使用Link和IndexLink导航" class="headerlink" title="使用Link和IndexLink导航"></a>使用Link和IndexLink导航</h3><p>如果使用<Link to='/'>Home</Link>去导航/这个URL。只要进入以/开头的URL时，Link组件都会被激活。<br>common/comtainer/Main.js</p>
<hr>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;PropTypes&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Link,IndexLink&#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Main</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">IndexLink</span> <span class="attr">to</span>=<span class="string">'/'</span> <span class="attr">activeStyle</span>=<span class="string">&#123;&#123;color:</span>'<span class="attr">red</span>'&#125;&#125;&gt;</span>Home<span class="tag">&lt;/<span class="name">IndexLink</span>&gt;</span></span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;&lt;IndexLink to='/</span>counter<span class="string">' activeStyle=&#123;&#123;color:'</span>red<span class="string">'&#125;&#125;Counter&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        &#123;/*this will render the child routes*/&#125;</span></span><br><span class="line"><span class="string">        &#123;React.cloneElement(props.children,props)&#125;</span></span><br><span class="line"><span class="string">       &lt;/div&gt;</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"> Main.propTypes =&#123;</span></span><br><span class="line"><span class="string">    children:PropTypes.any.isRequired          </span></span><br><span class="line"><span class="string"> &#125;;</span></span><br><span class="line"><span class="string"> export default Main;</span></span><br></pre></td></tr></table></figure>

<h3 id="服务端路由"><a href="#服务端路由" class="headerlink" title="服务端路由"></a>服务端路由</h3><p>在React-Router中实现服务端路由，需要在Express中间件中加一个用于匹配路由的match函数，并在match的回调中进行渲染就可以。</p>
<h2 id="server-server-js"><a href="#server-server-js" class="headerlink" title="server/server.js"></a>server/server.js</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRender</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> initialState =&#123;<span class="attr">counter</span>:<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> store = configureStore(initialState);</span><br><span class="line">    <span class="keyword">const</span> routes =getRoutes();</span><br><span class="line">    </span><br><span class="line">match(&#123;routes,<span class="attr">location</span>:req.url&#125;,(err,redirect,renderProps)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> html = renderToString(</span><br><span class="line">        &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">         &lt;RouterContext &#123;...renderProps&#125;/&gt;</span><br><span class="line">        &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    const finalState =store.getState();</span></span><br><span class="line"><span class="regexp">    res.send(renderFullPage(html,finalState)));</span></span><br><span class="line"><span class="regexp">    &#125;);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/第一个的参数是一个对象，包括所有路由集合和location</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/第二个参数是一个回调函数，渲染路由组件</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/match是专为异步路由设计的函数</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/match会根据不同的请求，在回掉函数中返回不同的参数：</span></span><br><span class="line"><span class="regexp">*     正确匹配，没有重定向，，前两个参数为null，renderProps包含了匹配的组件和location等信息</span></span><br><span class="line"><span class="regexp">*     有重定向，redirect将包含重定向信息</span></span><br><span class="line"><span class="regexp">*     出现内部错误，err将包含错误信息</span></span><br><span class="line"><span class="regexp">*     404错误下，三个参数均为undefined</span></span><br></pre></td></tr></table></figure>







      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/28/2017-03-28-redux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doreen">
      <meta itemprop="description" content="this  is a personal recordings for study & life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Doreen's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/28/2017-03-28-redux/" class="post-title-link" itemprop="url">react + redux</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-03-28 00:00:00" itemprop="dateCreated datePublished" datetime="2017-03-28T00:00:00+08:00">2017-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-04 16:47:10" itemprop="dateModified" datetime="2022-05-04T16:47:10+08:00">2022-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index"><span itemprop="name">FE</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="redux底层架构实现"><a href="#redux底层架构实现" class="headerlink" title="redux底层架构实现"></a>redux底层架构实现</h1><p>Redux是一种架构模式</p>
<p>React-redux 就是把 Redux 这种架构模式和 React.js 结合起来的一个库</p>
<p>dispatch 专门负责数据修改,接受一个参数action.</p>
<p>action是一个普通的js对象，里面必须包含一个type字段来声明用来做什么操作。</p>
<p>原来模块（组件）修改共享数据是直接改的,这样无法把控。</p>
<p>通过dispatch，所有数据修改必须通过它，并且必须用action来声明你的操作，只有它允许才能修改.</p>
<p>有了如下这种集合：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appState = &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    text: <span class="string">'React.js 小书'</span>,</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  content: &#123;</span><br><span class="line">    text: <span class="string">'React.js 小书内容'</span>,</span><br><span class="line">    color: <span class="string">'blue'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'UPDATE_TITLE_TEXT'</span>:</span><br><span class="line">      appState.title.text = action.text</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'UPDATE_TITLE_COLOR'</span>:</span><br><span class="line">      appState.title.color = action.color</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>把它们集中到一个地方，给这个地方起个名字叫做store，然后构建一个函数createStore，用来专门生产这种这种state和dispatch的集合，这样其他App也可以用这种模式了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">state,stateChanger</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> getState =<span class="function"><span class="params">()</span>=&gt;</span>state;</span><br><span class="line"><span class="keyword">const</span> dispatch =<span class="function">(<span class="params">action</span>)=&gt;</span>stateChanger(state,action);</span><br><span class="line"><span class="keyword">return</span> &#123;getState,dispatch&#125;</span><br></pre></td></tr></table></figure>


<p><code>createStore</code>接受两个参数，一个表示应用程序状态，另一个用来描述应用程序会根据<code>action</code>发生什么变化，相当于<code>dispatch</code>函数里面的内容。<br><code>createStore</code>会返回一个对象，这个对象里面包含两个方法<code>getState</code>和<code>dispatch</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> appState = &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    text: <span class="string">'React.js 小书'</span>,</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  content: &#123;</span><br><span class="line">    text: <span class="string">'React.js 小书内容'</span>,</span><br><span class="line">    color: <span class="string">'blue'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stateChanger</span> (<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'UPDATE_TITLE_TEXT'</span>:</span><br><span class="line">      state.title.text = action.text</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'UPDATE_TITLE_COLOR'</span>:</span><br><span class="line">      state.title.color = action.color</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(appState, stateChanger)</span><br><span class="line"></span><br><span class="line">renderApp(store.getState()) <span class="comment">// 首次渲染页面</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'UPDATE_TITLE_TEXT'</span>, <span class="attr">text</span>: <span class="string">'《React.js 小书》'</span> &#125;) <span class="comment">// 修改标题文本</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'UPDATE_TITLE_COLOR'</span>, <span class="attr">color</span>: <span class="string">'blue'</span> &#125;) <span class="comment">// 修改标题颜色</span></span><br><span class="line">renderApp(store.getState()) <span class="comment">// 把新的数据渲染到页面上</span></span><br></pre></td></tr></table></figure>


<p>针对每个不同的App，我们可以给<code>createStore</code>传入初始数据<code>appState</code> ，和一个描述数据变化的函数<code>stateChanger</code>，然后生成一个<code>store</code>，需要修改数据的时候通过<code>store.dispatch</code>,需要获取数据的时候通过<code>store.getState</code></p>
<h2 id="监控数据变化"><a href="#监控数据变化" class="headerlink" title="监控数据变化"></a>监控数据变化</h2><p>如上代码，我们每次通过<code>dispatch</code> 修改数据的时候，其实只是数据发生了变化，如果我们不手动调用 <code>renderApp</code>，页面上的内容是不会发生变化的。但是我们总不能每次 <code>dispatch</code>的时候都手动调用一下 <code>renderApp</code>，我们肯定希望数据变化的时候程序能够智能一点地自动重新渲染数据，而不是手动调用。</p>
<p>你说这好办，往 <code>dispatch</code>里面加<code>renderApp</code>就好了，但是这样<code>createStore</code> 就不够通用了。我们希望用一种通用的方式“监听”数据变化，然后重新渲染页面，这里要用到<strong><em>订阅者模式</em></strong>。修改 createStore：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">state, stateChanger</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> listeners = []</span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> listeners.push(listener)</span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    stateChanger(state, action)</span><br><span class="line">    listeners.forEach(<span class="function">(<span class="params">listener</span>) =&gt;</span> listener())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们在 <code>createStore</code> 里面定义了一个数组 <code>listeners</code>，还有一个新的方法 <code>subscribe</code>，可以通过 <code>store.subscribe(listener)</code> 的方式给 <code>subscribe</code> 传入一个监听函数，这个函数会被 push 到数组当中。</p>
<p>我们修改了 <code>dispatch</code>，每次当它被调用的时候，除了会调用<code>stateChanger</code> 进行数据的修改，还会遍历 <code>listeners</code> 数组里面的函数，然后一个个地去调用。相当于我们可以通过 <code>subscribe</code> 传入数据变化的监听函数，每当 dispatch 的时候，监听函数就会被调用，这样我们就可以在每当数据变化时候进行重新渲染：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(appState, stateChanger)</span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> renderApp(store.getState()))</span><br><span class="line"></span><br><span class="line">renderApp(store.getState()) <span class="comment">// 首次渲染页面</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'UPDATE_TITLE_TEXT'</span>, <span class="attr">text</span>: <span class="string">'《React.js 小书》'</span> &#125;) <span class="comment">// 修改标题文本</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'UPDATE_TITLE_COLOR'</span>, <span class="attr">color</span>: <span class="string">'blue'</span> &#125;) <span class="comment">// 修改标题颜色</span></span><br><span class="line"><span class="comment">// ...后面不管如何 store.dispatch，都不需要重新调用 renderApp</span></span><br></pre></td></tr></table></figure>


<p>现在我们有了一个比较通用的 <code>createStore</code>，它可以产生一种我们新定义的数据类型 <code>store</code>，通过 <code>store.getState</code> 我们获取共享状态，而且我们约定只能通过 <code>store.dispatch</code> 修改共享状态。<code>store</code> 也允许我们通过 <code>store.subscribe</code>监听数据数据状态被修改了，并且进行后续的例如重新渲染页面的操作。<br>我们接下来会继续优化我们的 <code>createStore</code>的模式，让它使我们的应用程序获得更好的性能。</p>
<h2 id="共享结构的对象"><a href="#共享结构的对象" class="headerlink" title="共享结构的对象"></a>共享结构的对象</h2><p>ES6中有这样的语法；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;...obj&#125; <span class="comment">//=&gt;&#123;a:1,b:2&#125;</span></span><br></pre></td></tr></table></figure>


<p><code>const obj2 = { ...obj }</code>其实就是新建一个对象 <code>obj2</code>，然后把<code>obj</code>所有的属性都复制到 <code>obj2</code> 里面，相当于对象的浅复制。上面的 <code>obj</code> 里面的内容和 <code>obj2</code>是完全一样的，但是却是两个<strong>不同的</strong>对象。除了浅复制对象，还可以覆盖、拓展对象属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; ...obj, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">4</span>&#125; <span class="comment">// =&gt; &#123; a: 1, b: 3, c: 4 &#125;，覆盖了 b，新增了 c</span></span><br></pre></td></tr></table></figure>


<p>我们可以把这种特性应用在<code>state</code> 的更新上，我们禁止直接修改原来的对象，一旦你要修改某些东西，你就得把修改路径上的所有对象复制一遍，例如，我们不写下面的修改代码：<br><code>appState.title.text = &#39;react&#39;</code><br>而是新建一个<code>appState</code>，新建<code>appState.title</code>，新建<code>appState.title.text</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newAppState =&#123;<span class="comment">//新建一个newAppState</span></span><br><span class="line">...appState,<span class="comment">//复制appState里面的内容</span></span><br><span class="line">title:&#123; <span class="comment">// 用一个新的对象覆盖原来的 title 属性</span></span><br><span class="line">  ...appState.title,<span class="comment">// 复制原来 title 对象里面的内容</span></span><br><span class="line">  text:<span class="string">'react'</span><span class="comment">// 覆盖 text 属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>appState</code> 和 <code>newAppState</code> 其实是两个不同的对象，因为对象浅复制的缘故，其实它们里面的属性 <code>content</code>指向的是同一个对象；但是因为 <code>title</code>被一个新的对象覆盖了，所以它们的 <code>title</code>属性是不同的。<br>我们每次修改某些数据的时候，都不会碰原来的数据，而是把需要修改数据路径上的对象都 copy 一个出来。这样有什么好处？看看我们的目的达到了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appState !== newAppState <span class="comment">// true，数据变化了，重新渲染</span></span><br><span class="line">appState.title !== newAppState.title <span class="comment">// true，数据变化了，重新渲染</span></span><br><span class="line">appState.content !== appState.content <span class="comment">// false，数据没有变化，不需要重新渲染</span></span><br></pre></td></tr></table></figure>

<h2 id="优化性能"><a href="#优化性能" class="headerlink" title="优化性能"></a>优化性能</h2><p>修改<code>stateChanger</code>，让它修改数据的时候，并不会直接修改原来的数据 <code>state</code>，而是产生上述的共享结构的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stateChanger</span> (<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'UPDATE_TITLE_TEXT'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="comment">// 构建新的对象并且返回</span></span><br><span class="line">        ...state,</span><br><span class="line">        title: &#123;</span><br><span class="line">          ...state.title,</span><br><span class="line">          text: action.text</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'UPDATE_TITLE_COLOR'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="comment">// 构建新的对象并且返回</span></span><br><span class="line">        ...state,</span><br><span class="line">        title: &#123;</span><br><span class="line">          ...state.title,</span><br><span class="line">          color: action.color</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state <span class="comment">// 没有修改，返回原来的对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次需要修改的时候都会产生新的对象，并且返回。而如果没有修改（在 default 语句中）则返回原来的 state 对象。</p>
<p>因为<code>stateChanger</code> 不会修改原来对象了，而是返回对象，所以我们需要修改一下 <code>createStore</code>。让它用每次 <code>stateChanger(state, action)</code>的调用结果覆盖原来的 state：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">state, stateChanger</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> listeners = []</span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> listeners.push(listener)</span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    state = stateChanger(state, action) <span class="comment">// 覆盖原对象</span></span><br><span class="line">    listeners.forEach(<span class="function">(<span class="params">listener</span>) =&gt;</span> listener())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再优化一下，其实<code>appState</code>和 <code>stateChanger</code> 可以合并到一起去：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stateChanger</span> (<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!state) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      title: &#123;</span><br><span class="line">        text: <span class="string">'React.js 小书'</span>,</span><br><span class="line">        color: <span class="string">'red'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      content: &#123;</span><br><span class="line">        text: <span class="string">'React.js 小书内容'</span>,</span><br><span class="line">        color: <span class="string">'blue'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'UPDATE_TITLE_TEXT'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        title: &#123;</span><br><span class="line">          ...state.title,</span><br><span class="line">          text: action.text</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'UPDATE_TITLE_COLOR'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        title: &#123;</span><br><span class="line">          ...state.title,</span><br><span class="line">          color: action.color</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>stateChanger</code> 现在既充当了获取初始化数据的功能，也充当了生成更新数据的功能。如果有传入 <code>state</code> 就生成更新数据，否则就是初始化数据。这样我们可以优化 <code>createStore</code>成一个参数，因为 <code>state</code> 和<code>stateChanger</code> 合并到一起了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">stateChanger</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">const</span> listeners = []</span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> listeners.push(listener)</span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> state</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    state = stateChanger(state, action)</span><br><span class="line">    listeners.forEach(<span class="function">(<span class="params">listener</span>) =&gt;</span> listener())</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(&#123;&#125;) <span class="comment">// 初始化 state</span></span><br><span class="line">  <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们给 stateChanger 这个玩意起一个通用的名字：<code>reducer</code></p>
<h2 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h2><p><code>createStore</code>接受一个叫 <code>reducer</code> 的函数作为参数，这个函数规定是一个纯函数，它接受两个参数，一个是 <code>state</code>，一个是 <code>action</code>。</p>
<p>如果没有传入<code>state</code>或者 <code>state</code>是 null，那么它就会返回一个初始化的数据。如果有传入 <code>state</code> 的话，就会根据 <code>action</code> 来“修改“数据，但其实它没有、也规定不能修改 state，而是要通过上节所说的把修改路径的对象都复制一遍，然后产生一个新的对象返回。如果它不能识别你的 <code>action</code>，它就不会产生新的数据，而是（在 default 内部）把 <code>state</code> 原封不动地返回。</p>
<p><code>reducer</code> 是不允许有副作用的。你不能在里面操作 DOM，也不能发 Ajax 请求，更不能直接修改<code>state</code>，它要做的仅仅是 —— <strong>初始化和计算新的<code>state</code></strong>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>createStore</code>现在可以直接拿来用了，套路就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定一个 reducer</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span> (<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 初始化 state 和 switch case */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 store</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听数据变化重新渲染页面</span></span><br><span class="line">store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> renderApp(store.getState()))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次渲染页面</span></span><br><span class="line">renderApp(store.getState()) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面可以随意 dispatch 了，页面自动更新</span></span><br><span class="line">store.dispatch(...)</span><br></pre></td></tr></table></figure>



<p>现在的代码跟 React.js 一点关系都没有，接下来我们要把 React.js 和 Redux 结合起来，用 Redux 模式帮助管理 React.js 的应用状态。</p>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>前端中应用的状态存在的问题：一个状态可能被多个组件依赖或者影响，而 React.js 并没有提供好的解决方案，我们只能把状态提升到依赖或者影响这个状态的所有组件的公共父组件上，我们把这种行为叫做状态提升。但是需求不停变化，共享状态没完没了地提升也不是办法。<br>后来我们在 React.js 的 context 中提出，我们可用把共享状态放到父组件的 context 上，这个父组件下所有的组件都可以从 context 中直接获取到状态而不需要一层层地进行传递了。但是直接从 context 里面存放、获取数据增强了组件的耦合性；并且所有组件都可以修改 context 里面的状态就像谁都可以修改共享状态一样，导致程序运行的不可预料。</p>
<p>既然这样，为什么不把 context 和 store 结合起来？毕竟 store 的数据不是谁都能修改，而是约定只能通过 dispatch 来进行修改，这样的话每个组件既可以去 context 里面获取 store 从而获取状态，又不用担心它们乱改数据了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/16/2017-03-16-React/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doreen">
      <meta itemprop="description" content="this  is a personal recordings for study & life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Doreen's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/16/2017-03-16-React/" class="post-title-link" itemprop="url">React分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-03-16 00:00:00" itemprop="dateCreated datePublished" datetime="2017-03-16T00:00:00+08:00">2017-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-04 16:47:10" itemprop="dateModified" datetime="2022-05-04T16:47:10+08:00">2022-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index"><span itemprop="name">FE</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/React/" itemprop="url" rel="index"><span itemprop="name">React</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="react认识"><a href="#react认识" class="headerlink" title="react认识"></a>react认识</h2><p><strong>有一段解释很透彻：</strong><br>用脚本进行DOM操作的代价很昂贵。有个贴切的比喻，把DOM和JavaScript各自想象为一个岛屿，它们之间用收费桥梁连接，js每次访问DOM，都要途径这座桥，并交纳“过桥费”,访问DOM的次数越多，费用也就越高。 因此，推荐的做法是尽量减少过桥的次数，努力待在ECMAScript岛上。<br>因为这个原因react的虚拟dom就显得难能可贵了，它创造了<strong>虚拟dom</strong>并且将它们储存起来，每当状态发生变化的时候就会创造新的<strong>虚拟节点</strong>和以前的进行对比（Diff算法），让变化的部分进行渲染。整个过程没有对dom进行获取和操作，只有一个<strong>渲染</strong>的过程，所以react说是一个<strong>ui框架</strong>。</p>
<h2 id="react组件化"><a href="#react组件化" class="headerlink" title="react组件化"></a>react组件化</h2><p>react的一个组件很明显的由<strong>dom视图</strong>和<strong>state数据</strong>组成，两个部分泾渭分明。<br>state是数据中心，它的状态决定着视图的状态。这时候发现似乎和我们一直推崇的MVC开发模式有点区别，没了Controller控制器，那用户交互怎么处理，数据变化谁来管理？然而这并不是react所要关心的事情，它只负责ui的渲染。与其他框架监听数据动态改变dom不同，react采用setState来控制视图的更新。setState会自动调用render函数，触发视图的重新渲染，如果仅仅只是state数据的变化而没有调用setState，并不会触发更新。<br>组件就是拥有独立功能的视图模块，许多小的组件组成一个大的组件，整个页面就是由一个个组件组合而成。它的好处是利于重复利用和维护。</p>
<h2 id="react-diff算法"><a href="#react-diff算法" class="headerlink" title="react diff算法"></a>react diff算法</h2><p>eact的diff算法用在什么地方呢？当组件更新的时候，react会创建一个新的虚拟dom树并且会和之前储存的dom树进行比较，这个比较多过程就用到了diff算法，所以组件初始化的时候是用不到的。react提出了一种假设，相同的节点具有类似的结构，而不同的节点具有不同的结构。在这种假设之上进行逐层的比较，如果发现对应的节点是不同的，那就直接删除旧的节点以及它所包含的所有子节点然后替换成新的节点。如果是相同的节点，则只进行属性的更改。</p>
<p>对于列表的diff算法稍有不同，因为列表通常具有相同的结构，在对列表节点进行删除，插入，排序的时候，单个节点的整体操作远比一个个对比一个个替换要好得多，所以在创建列表的时候需要设置key值，这样react才能分清谁是谁。当然不写key值也可以，但这样通常会报出警告，通知我们加上key值以提高react的性能。<br><img src="https://segmentfault.com/img/remote/1460000007642743?w=736&h=409" alt=""></p>
<h2 id="react组件写法"><a href="#react组件写法" class="headerlink" title="react组件写法"></a>react组件写法</h2><p>组件的创造方法为React.createClass() ——创造一个类，react系统内部设计了一套类系统，利用它来创造react组件。但这并不是必须的，我们还可以用es6的class类来创造组件,这也是Facebook官方推荐的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state =&#123;</span><br><span class="line">      params:<span class="string">''</span>,</span><br><span class="line">      MyList:[]</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这两种写法实现的功能一样但是原理却是不同，es6的class类可以看作是构造函数的一个语法糖，可以把它当成构造函数来看，extends实现了类之间的继承 —— 定义一个类MyComponent继承React.Component所有的属性和方法，组件的生命周期函数就是从这来的。<br>constructor是构造器，在实例化对象时调用，super调用了父类的constructor创造了父类的实例对象this，然后用子类的构造函数进行修改。这和es5的原型继承是不同的，原型继承是先创造一个实例化对象this，然后再继承父级的原型方法。<br>当我们使用组件<MyComponent/>时，其实是对MyComponent类的实例化，只不过react对这个过程进行了封装，使其看起来像一个标签。<br>props访问父组件的属性<br>this.props.children 访问组件的孩子节点<br>可以用React.Children.map()遍历this.props.children</p>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p><img src="https://segmentfault.com/img/remote/1460000007642745?w=2803&h=2945" alt=""></p>
<h3 id="组件在初始化时会触发5个钩子函数："><a href="#组件在初始化时会触发5个钩子函数：" class="headerlink" title="组件在初始化时会触发5个钩子函数："></a>组件在初始化时会触发5个钩子函数：</h3><ol>
<li>getDefaultProps() :😀设置，默认的props，也可以用defaultProps设置组件的默认属性。</li>
<li>getInitialState() ：在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。</li>
<li>componentWillMount()：件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。</li>
<li>render() ：react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。</li>
<li>componentDidMount() ：组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。</li>
</ol>
<h3 id="组件在更新时也会触发5个钩子函数："><a href="#组件在更新时也会触发5个钩子函数：" class="headerlink" title="组件在更新时也会触发5个钩子函数："></a>组件在更新时也会触发5个钩子函数：</h3><p>1.componentWillReceiveProps(nextProps) :组件初始化时不调用，组件接受新的props时调用。<br>2. shouldComponentUpdate(nextProps,nextState) :<strong>react性能优化非常重要的一环</strong>。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。<br>3. componentWillUpdate(nextProps,nextState) :组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state<br>4. render()<br>5. componentDidUpdate() :组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。</p>
<h2 id="继承React-Component的类的方法时遵循下面的顺序"><a href="#继承React-Component的类的方法时遵循下面的顺序" class="headerlink" title="继承React.Component的类的方法时遵循下面的顺序"></a>继承React.Component的类的方法时遵循下面的顺序</h2><ol>
<li>constructor</li>
<li>optional static methods</li>
<li>getChildContext</li>
<li>componentWillMount</li>
<li>componentDidMount</li>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>componentDidUpdate</li>
<li>componentWillUnmount</li>
<li>点击回调或者事件回调，比如onClickSubmit()或者onChangeDescription()</li>
<li>render函数中的getter()方法，，比如getSelectReason()或者getFooterContent()</li>
<li>可选的render方法</li>
<li>render</li>
</ol>
<h2 id="react-router路由"><a href="#react-router路由" class="headerlink" title="react-router路由"></a>react-router路由</h2><p>Router就是react的一个组件，并不会被渲染，只是一个创建内部路由规则的配置对象，根据匹配的路由地址展现相应的组件。<br>Router则对路由地址和组件进行绑定，Router具有嵌套功能，表示路由地址的包含关系，这和组件的嵌套没有直接联系。<br>Router可以向绑定的组件传递7个属性：children，history，location，params，route，routeParams，routes，每个属性都包涵路由的相关的信息。比较常用的有children（以路由的包涵关系为区分的组件），location（包括地址，参数，地址切换方式，key值，hash值）。react-router提供Link标签，这只是对a标签的封装，值得注意的是，点击链接进行的跳转并不是默认的方式，react-router阻止了a标签的默认行为并用pushState进行hash值的转变。切换页面的过程是在点击Link标签或者后退前进按钮时，会先发生url地址的转变，Router监听到地址的改变根据Route的path属性匹配到对应的组件，将state值改成对应的组件并调用setState触发render函数重新渲染dom。<br>当页面比较多时，项目就会变得越来越大，尤其对于单页面应用来说，初次渲染的速度就会很慢，这时候就需要按需加载，只有切换到页面的时候才去加载对应的js文件。react配合webpack进行按需加载的方法很简单，Route的component改为getComponent，组件用require.ensure的方式获取，并在webpack中配置chunkFilename。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chooseProducts = <span class="function">(<span class="params">location, cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;</span><br><span class="line">        cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'../Component/chooseProducts'</span>).default)</span><br><span class="line">    &#125;,<span class="string">'chooseProducts'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> helpCenter = <span class="function">(<span class="params">location, cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;</span><br><span class="line">        cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'../Component/helpCenter'</span>).default)</span><br><span class="line">    &#125;,<span class="string">'helpCenter'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> saleRecord = <span class="function">(<span class="params">location, cb</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;</span><br><span class="line">        cb(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'../Component/saleRecord'</span>).default)</span><br><span class="line">    &#125;,<span class="string">'saleRecord'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> RouteConfig = (</span><br><span class="line">    &lt;Router history=&#123;history&#125;&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"/"</span> component=&#123;Roots&#125;&gt;</span><br><span class="line">            &lt;IndexRoute component=&#123;index&#125; /&gt;<span class="comment">//首页</span></span><br><span class="line">            &lt;Route path=<span class="string">"index"</span> component=&#123;index&#125; /&gt;</span><br><span class="line">            &lt;Route path=<span class="string">"helpCenter"</span> getComponent=&#123;helpCenter&#125; /&gt;<span class="comment">//帮助中心</span></span><br><span class="line">            &lt;Route path=<span class="string">"saleRecord"</span> getComponent=&#123;saleRecord&#125; /&gt;<span class="comment">//销售记录</span></span><br><span class="line">            &lt;Redirect <span class="keyword">from</span>=<span class="string">'*'</span> to=<span class="string">'/'</span>  /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Router&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="组件之间的通信"><a href="#组件之间的通信" class="headerlink" title="组件之间的通信"></a>组件之间的通信</h2><p>react推崇的是单向数据流，自上而下进行数据的传递，但是由下而上或者不在一条数据流上的组件之间的通信就会变的复杂。解决通信问题的方法很多，如果只是父子级关系，父级可以将一个回调函数当作属性传递给子级，子级可以直接调用函数从而和父级通信。</p>
<p>组件层级嵌套到比较深，可以使用上下文getChildContext来传递信息，这样在不需要将函数一层层往下传，任何一层的子级都可以通过this.context直接访问。</p>
<p>兄弟关系的组件之间无法直接通信，它们只能利用同一层的上级作为中转站。而如果兄弟组件都是最高层的组件，为了能够让它们进行通信，必须在它们外层再套一层组件，这个外层的组件起着保存数据，传递信息的作用，这其实就是redux所做的事情。</p>
<p>组件之间的信息还可以通过全局事件来传递。不同页面可以通过参数传递数据，下个页面可以用location.param来获取。其实react本身很简单，难的在于如何优雅高效的实现组件之间数据的交流。</p>
<h1 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h1><h2 id="redux作用"><a href="#redux作用" class="headerlink" title="redux作用"></a>redux作用</h2><p>首先，redux并不是必须的，它的作用相当于在顶层组件之上又加了一个组件，作用是进行逻辑运算、储存数据和实现组件尤其是顶层组件的通信。如果组件之间的交流不多，逻辑不复杂，只是单纯的进行视图的渲染，这时候用回调，context就行，没必要用redux，用了反而影响开发速度。但是如果组件交流特别频繁，逻辑很复杂，那redux的优势就特别明显了。<br>   Redux 的react绑定库是基于 <strong>容器组件和展示组件相分离</strong> 的开发思想。</p>
<h2 id="redux和react如何配合"><a href="#redux和react如何配合" class="headerlink" title="redux和react如何配合"></a>redux和react如何配合</h2><p>react-redux提供了connect和Provider两个好基友，它们一个将组件与redux关联起来，一个将store传给组件。组件通过dispatch发出action，store根据action的type属性调用对应的reducer并传入state和这个action，reducer对state进行处理并返回一个新的state放入store，connect监听到store发生变化，调用setState更新组件，此时组件的props也就跟着变化。<br>流程如下：<br><img src="https://segmentfault.com/img/remote/1460000007642746?w=638&h=479" alt=""><br>connect，Provider，mapStateToProps,mapDispatchToProps是react-redux提供的，redux本身和react没有半毛钱关系，它只是数据处理中心，没有和react产生任何耦合，是react-redux让它们联系在一起<br><img src="https://segmentfault.com/img/remote/1460000007642747?w=1286&h=1246" alt=""><br>redux 主要由三部分组成：store，reducer，action</p>
<h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>store是一个对象，有四个主要方法：</p>
<ol>
<li><p>dispatch：</p>
<blockquote>
<p>用于action的分发——在createStore中可以用middleware中间件对dispatch进行改造，比如当action传入dispatch会立即触发reducer，有些时候我们不希望它立即触发，而是等待异步操作完成之后再触发，这时候用redux-thunk对dispatch进行改造，以前只能传入一个对象，改造完成后可以传入一个函数，在这个函数里我们手动dispatch一个action对象，这个过程是可控的，就实现了异步。</p>
</blockquote>
</li>
<li><p>subscribe：</p>
<blockquote>
<p>监听state的变化——这个函数在store调用dispatch时会注册一个listener监听state变化，当我们需要知道state是否变化时可以调用，它返回一个函数，调用这个返回的函数可以注销监听</p>
</blockquote>
</li>
<li><p>getState：</p>
<blockquote>
<p>获取store中的state——当我们用action触发reducer改变了state时，需要再拿到新的state里的数据，毕竟数据才是我们想要的。getState主要在两个地方需要用到，一是在dispatch拿到action后store需要用它来获取state里的数据，并把这个数据传给reducer，这个过程是自动执行的，二是在我们利用subscribe监听到state发生变化后调用它来获取新的state数据，如果做到这一步，说明我们已经成功了</p>
</blockquote>
</li>
<li><p>replaceReducer：</p>
<blockquote>
<p>替换reducer，改变state修改的逻辑</p>
</blockquote>
</li>
</ol>
<h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>action是一个对象，其中type属性是必须的，同时可以传入一些数据。action可以用actionCreator进行创造。dispatch就是把action对象发送出去。</p>
<h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>官网上是这么定义的</p>
<blockquote>
<p><strong>Actions</strong> describe the fact that something happened, but don’t specify how the application’s state changes in response. This is the job of reducers.</p>
</blockquote>
<p>reducer是一个函数，它接受一个state和一个action，根据action的type返回一个新的state。根据业务逻辑可以分为很多个reducer，然后通过combineReducers将它们合并，state树中有很多对象，每个state对象对应一个reducer，state对象的名字可以在合并时定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const reducer &#x3D;combineReducers(&#123;</span><br><span class="line"> a:doSometingWithA,</span><br><span class="line"> b:processB,</span><br><span class="line"> c:c</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure>

<h3 id="comebineReducers"><a href="#comebineReducers" class="headerlink" title="comebineReducers"></a>comebineReducers</h3><p>其实它也是一个reducer，它接受整个state和一个action，然后将整个state拆分发送给对应的reducer进行处理，所有的reducer会收到相同的action，不过它们会根据action的type进行判断，有这个type就进行处理然后返回新的state，没有就返回默认值，然后这些分散的state又会整合在一起返回一个新的state树。</p>
<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>首先调用store.dispatch将action作为参数传入，同时用调用getState获取当前的状态树state并注册subscribe的listener监听state变化，再调用combineReducers并将获取的state和action传入。combineReducers会将传入的state和action传给所有reducer，reducer会根据state的key值获取与自己对应的state，并根据action的type返回新的state，触发state树的更新，我们调用subscribe监听到state发生变化后用getState获取新的state数据。<br><strong>redux的state和react的state两者完全没有关系，除了名字一样。</strong></p>
<h2 id="React-Redux"><a href="#React-Redux" class="headerlink" title="React-Redux"></a>React-Redux</h2><p>若只使用redux，流程是这样：</p>
<blockquote>
<p>component –&gt; dispatch(action) –&gt; reducer –&gt; subscribe –&gt; getState –&gt; component</p>
</blockquote>
<p>使用react-redux之后，流程：</p>
<blockquote>
<p>component –&gt; actionCreator(data) –&gt; reducer –&gt; component</p>
</blockquote>
<p>store的三大功能：dispatch，subscribe，getState都不需要手动来写了。react-redux帮我们做了这些，同时它提供了两个好基友Provider和connect。<br><strong>Provider</strong>是一个组件，它接受store作为props，然后通过context往下传，这样react中任何组件都可以通过contex获取store。也就意味着我们可以在任何一个组件里利用dispatch(action)来触发reducer改变state，并用subscribe监听state的变化，然后用getState获取变化后的值。但是并不推荐这样做，它会让数据流变的混乱，过度的耦合也会影响组件的复用，维护起来也更麻烦。<br><strong>Connect</strong> –connect(mapStateToProps, mapDispatchToProps, mergeProps, options)是一个函数，它接受四个参数并且再返回一个函数–wrapWithConnect，wrapWithConnect接受一个组件作为参数wrapWithConnect(component)，它内部定义一个新组件Connect(容器组件)并将传入的组件(ui组件)作为Connect的子组件然后return出去。</p>
<p><strong>mapStateToProps(state, [ownProps])：</strong></p>
<blockquote>
<p>mapStateToProps 接受两个参数，store的state和自定义的props，并返回一个新的对象，这个对象会作为props的一部分传入ui组件。我们可以根据组件所需要的数据自定义返回一个对象。ownProps的变化也会触发mapStateToProps</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;<span class="attr">todos</span>:state.todos&#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>mapDispatchToProps(dispatch,[ownProps]):</strong></p>
<blockquote>
<p>mapDispatchToProps如果是对象，那么会和store绑定作为props的一部分传入ui组件。如果是个函数，它接受两个参数，bindActionCreators会将action和dispatch绑定并返回一个对象，这个对象会和ownProps一起作为props的一部分传入ui组件。所以不论mapDispatchToProps是对象还是函数，它最终都会返回一个对象，如果是函数，这个对象的key值是可以自定义的.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">      todoActions: bindActionCreators(todoActionCreators, dispatch),</span><br><span class="line">      counterActions: bindActionCreators(counterActionCreators, dispatch)</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mapDispatchToProps返回的对象其属性其实就是一个个actionCreator，因为已经和dispatch绑定，所以当调用actionCreator时会立即发送action，而不用手动dispatch。ownProps的变化也会触发mapDispatchToProps.</p>
<p><strong>mergeProps(stateProps,dispatchProps,ownProps):</strong></p>
<blockquote>
<p>将mapStateToProps() 与 mapDispatchToProps()返回的对象和组件自身的props合并成新的props并传入组件。默认返回 Object.assign({}, ownProps, stateProps, dispatchProps) 的结果。</p>
</blockquote>
<p><strong>options:</strong></p>
<blockquote>
<p>pure = true 表示Connect容器组件将在shouldComponentUpdate中对store的state和ownProps进行浅对比，判断是否发生变化，优化性能。为false则不对比。</p>
</blockquote>
<h2 id="完整的react-redux-react流程"><a href="#完整的react-redux-react流程" class="headerlink" title="完整的react-redux-react流程"></a>完整的react-redux-react流程</h2><p>一、Provider组件接受redux的store作为props，然后通过context往下传。</p>
<p>二、connect函数在初始化的时候会将mapDispatchToProps对象绑定到store，如果mapDispatchToProps是函数则在Connect组件获得store后，根据传入的store.dispatch和action通过bindActionCreators进行绑定，再将返回的对象绑定到store，connect函数会返回一个wrapWithConnect函数，同时wrapWithConnect会被调用且传入一个ui组件，wrapWithConnect内部使用class Connect extends Component定义了一个Connect组件，传入的ui组件就是Connect的子组件，然后Connect组件会通过context获得store，并通过store.getState获得完整的state对象，将state传入mapStateToProps返回stateProps对象、mapDispatchToProps对象或mapDispatchToProps函数会返回一个dispatchProps对象，stateProps、dispatchProps以及Connect组件的props三者通过Object.assign()，或者mergeProps合并为props传入ui组件。然后在ComponentDidMount中调用store.subscribe，注册了一个回调函数handleChange监听state的变化。</p>
<p>三、此时ui组件就可以在props中找到actionCreator，当我们调用actionCreator时会自动调用dispatch，在dispatch中会调用getState获取整个state，同时注册一个listener监听state的变化，store将获得的state和action传给combineReducers，combineReducers会将state依据state的key值分别传给子reducer，并将action传给全部子reducer，reducer会被依次执行进行action.type的判断，如果有则返回一个新的state，如果没有则返回默认。combineReducers再次将子reducer返回的单个state进行合并成一个新的完整的state。此时state发生了变化。Connect组件中调用的subscribe会监听到state发生了变化，然后调用handleChange函数，handleChange函数内部首先调用getState获取新的state值并对新旧两个state进行浅对比，如果相同直接return，如果不同则调用mapStateToProps获取stateProps并将新旧两个stateProps进行浅对比，如果相同，直接return结束，不进行后续操作。如果不相同则调用this.setState()触发Connect组件的更新，传入ui组件，触发ui组件的更新，此时ui组件获得新的props，react –&gt; redux –&gt; react 的一次流程结束。</p>
<h2 id="简化版流程"><a href="#简化版流程" class="headerlink" title="简化版流程"></a>简化版流程</h2><p>一、Provider组件接受redux的store作为props，然后通过context往下传。</p>
<p>二、connect函数收到Provider传出的store，然后接受三个参数mapStateToProps，mapDispatchToProps和组件，并将state和actionCreator以props传入组件，这时组件就可以调用actionCreator函数来触发reducer函数返回新的state，connect监听到state变化调用setState更新组件并将新的state传入组件。</p>
<p>connect可以写的非常简洁，mapStateToProps，mapDispatchToProps只不过是传入的回调函数，connect函数在必要的时候会调用它们，名字不是固定的，甚至可以不写名字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(<span class="function"><span class="params">state</span> =&gt;</span> state,action)(Component);</span><br></pre></td></tr></table></figure>

<h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><ol>
<li>先引用react.js,redux,react-router等基本文件，用npm安装，直接在文件中引用。</li>
<li>从react.js,redux,react-router 中引入所需要的对象和方法。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component, PropTypes&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM, &#123;render&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Provider, connect&#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createStore, combineReducers, applyMiddleware&#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Router, Route, Redirect, IndexRoute, browserHistory, hashHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>根据需求创建顶层ui组件，每个顶层ui组件对应一个页面。</li>
<li>创建actionCreators和reducers，并用combineReducers将所有的reducer合并成一个大的reduer。利用createStore创建store并引入combineReducers和applyMiddleware。</li>
<li>利用connect将actionCreator，reuder和顶层的ui组件进行关联并返回一个新的组件。</li>
<li>利用connect返回的新的组件配合react-router进行路由的部署，返回一个路由组件Router。</li>
<li>将Router放入最顶层组件Provider，引入store作为Provider的属性。</li>
<li>调用render渲染Provider组件且放入页面的标签中。<br>可以看到顶层的ui组件其实被套了四层组件，Provider，Router，Route，Connect，这四个组件并不会在视图上改变react，它们只是功能性的。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/14/2017-03-14-CSS3%20%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doreen">
      <meta itemprop="description" content="this  is a personal recordings for study & life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Doreen's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/14/2017-03-14-CSS3%20%E8%AF%AD%E6%B3%95/" class="post-title-link" itemprop="url">CSS语法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-03-14 00:00:00" itemprop="dateCreated datePublished" datetime="2017-03-14T00:00:00+08:00">2017-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-04 16:47:10" itemprop="dateModified" datetime="2022-05-04T16:47:10+08:00">2022-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index"><span itemprop="name">FE</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CSS3-语法"><a href="#CSS3-语法" class="headerlink" title="CSS3 语法"></a>CSS3 语法</h2><p>first-of-type :用来定位一个父元素下的某个类型的第一个子元素。</p>
<p>nth-of-type (n):</p>
<p>last-of-type:</p>
<p>only-child:选择父元素中只有一个子元素，且只有唯一的一个子元素。</p>
<p>only-of-type:一个父元素有很多元素，而其中只有一种类型的子元素是唯一的，选中这个元素中唯一一个类型的子元素。</p>
<p>enabled: 用于选择可用表单元素</p>
<p>disabled：用于选择不可用表单元素</p>
<p>checked:选中状态 常用于自定义样式</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper”&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">	&lt;div class="</span><span class="attr">box</span>"&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>  <span class="attr">id</span>=<span class="string">"boy"</span> ''<span class="attr">name</span>=<span class="string">"1"</span> /&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"boy"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span>  <span class="attr">id</span>=<span class="string">"girl"</span> <span class="attr">name</span>=<span class="string">"1"</span>  /&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"girl"</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">display</span>:inlne-block;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">background</span>: orange;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">z-index</span>:<span class="number">100</span>;<span class="comment">/*使input按钮在span的上一层，不加点击区域会出现不灵敏*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">span</span> &#123; </span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: -<span class="number">5px</span> <span class="number">0</span>  <span class="number">0</span> -<span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">z-index</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">"radio"</span>]</span> + <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">"radio"</span>]</span><span class="selector-pseudo">:checked</span> + <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>selection伪元素， 匹配突出显示的文本</p>
<p>:read-only </p>
<p>before/after 用来给元素的前面或后面插入内容，常和content配合使用，使用场景最多的是清除浮动。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line">	<span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">	    <span class="attribute">content</span>: <span class="string">"."</span>;</span><br><span class="line">	    <span class="attribute">display</span>: block;</span><br><span class="line">	    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">	    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;<span class="attribute">clear</span>: both;&#125;</span><br><span class="line">	<span class="selector-class">.clearfix</span> &#123;<span class="attribute">zoom</span>: <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>


<h3 id="实现阴影框效果"><a href="#实现阴影框效果" class="headerlink" title="实现阴影框效果"></a>实现阴影框效果</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.effect</span><span class="selector-pseudo">::before</span>, <span class="selector-class">.effect</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">	    <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">	    <span class="attribute">position</span>:absolute;</span><br><span class="line">	    <span class="attribute">z-index</span>:-<span class="number">1</span>;</span><br><span class="line">	    <span class="attribute">-webkit-box-shadow</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.8</span>);</span><br><span class="line">	    <span class="attribute">-moz-box-shadow</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.8</span>);</span><br><span class="line">	    <span class="attribute">box-shadow</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.8</span>);</span><br><span class="line">	    <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">	    <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">	    <span class="attribute">left</span>:<span class="number">10px</span>;</span><br><span class="line">	    <span class="attribute">right</span>:<span class="number">10px</span>;</span><br><span class="line">	    <span class="attribute">-moz-border-radius</span>:<span class="number">100px</span> / <span class="number">10px</span>;</span><br><span class="line">	    <span class="attribute">border-radius</span>:<span class="number">100px</span> / <span class="number">10px</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="给背景图添加蒙板效果可以用before"><a href="#给背景图添加蒙板效果可以用before" class="headerlink" title="给背景图添加蒙板效果可以用before"></a>给背景图添加蒙板效果可以用before</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">            <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">            <span class="attribute">display</span>: block;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">120px</span>;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">            <span class="attribute">border</span>: <span class="number">5px</span> solid <span class="number">#fff</span>;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">position</span>: absolute;</span><br><span class="line">            <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">            <span class="attribute">margin-left</span>: -<span class="number">60px</span>;</span><br><span class="line">            <span class="attribute">z-index</span>: <span class="number">99999</span>;</span><br><span class="line">            <span class="attribute">top</span>: -<span class="number">80px</span>;</span><br><span class="line">            <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.3</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h3 id="CSS变形和动画"><a href="#CSS变形和动画" class="headerlink" title="CSS变形和动画"></a>CSS变形和动画</h3><p>动画效果：transform：（属性值）</p>
<p><strong>rotate(xdeg)</strong>设置一个角度值，用来指定旋转的幅度。如果这个值为正值，元素相对原点中心顺时针旋转；如果这个值为负<br>值，元素相对原点中心逆时针旋转</p>
<p><strong>skew(x,y)</strong>使元素在水平和垂直方向同时扭曲</p>
<p><strong>skewX(x)</strong>仅使元素在水平方向扭曲变形（X轴扭曲变形）</p>
<p><strong>skewY(y)</strong>仅使元素在竖直方向扭曲变形</p>
<p><strong>scale(X,Y)</strong>使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）</p>
<p><strong>translate(x,y)</strong> 使用translate()函数，可以把元素从原来的位置移动，而不影响在X、Y轴上的任何Web组件。常用于实现在不确定宽高的元素实现水平和垂直居中。</p>
<p><strong>transition</strong></p>
<p>transition-property<br>transition-timing-function<br>transition-delay**</p>
<p>关键帧KeyFrames<br>以“@keyframes”开头，后面紧跟着是动画名称加上一对花括号“…”，括号中就是一些不同时间段样式规则.<br>    @keyframes changecolor{<br>      0%{<br>       background: red;<br>      }<br>      100%{<br>        background: green;<br>      }<br>    }<br>通过animation调用</p>
<p>animation-duration</p>
<p>animation-name</p>
<p>animation-timing-function:ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) <a href="#">, ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)</a>*</p>
<p>animation-iteration-count: infinite | &lt;number&gt; <a href="#">, infinite | &lt;number&gt;</a>*</p>
<p>animation-play-state:paused/running</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/10/2017-03-10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doreen">
      <meta itemprop="description" content="this  is a personal recordings for study & life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Doreen's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/10/2017-03-10-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">动态规划算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-03-10 00:00:00" itemprop="dateCreated datePublished" datetime="2017-03-10T00:00:00+08:00">2017-03-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-04 16:47:10" itemprop="dateModified" datetime="2022-05-04T16:47:10+08:00">2022-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index"><span itemprop="name">algorithm</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h2><h3 id="动态规划算法基本概念"><a href="#动态规划算法基本概念" class="headerlink" title="动态规划算法基本概念"></a>动态规划算法基本概念</h3><p>动态规划的过程：每次决策依赖于当前状态，又随机引起状态的转移。一个决策序列就是在变化的状态中产生出来的，是一种多阶段最优化决策解决问题的过程。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息，在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其它局部解。</p>
<h3 id="实际问题"><a href="#实际问题" class="headerlink" title="实际问题"></a>实际问题</h3><blockquote>
<h4 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h4><p><img src="http://img.blog.csdn.net/20150811133448624?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="数字三角形"></p>
</blockquote>
<p> 在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往左下或 右下走。只需要求出这个最大和即可，不必给出具体路径。 三角形的行数大于1小于等于100，数字为 0 - 99。<br>输入格式：</p>
<pre><code>5      //表示三角形的行数    

7

3   8

8   1   0

2   7   4   4

4   5   2   6   5

要求输出最大和</code></pre><h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>用一个二期数组存放数字三角形<br>用D[i,j]表示第i行第j个数字（i 和j 均从1开始）<br>用MaxSum[i,j]表示从D[i,j]到底边的各条路径的和的最大值。<br>因此，问题改为求MaxSum[1,1];</p>
<hr>
<p>用递归解决,递归方程如下：<br><em>MaxSum[i,j] = D[i,j]  i=N<br>MaxSum[i,j] = Max(MaxSum[i+1,j],MaxSum[i+1,j+1])+D[i,j] i!=N</em><br>根据递归方程可得代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;Math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int D[101][101];</span><br><span class="line">int n;</span><br><span class="line">int MaxSum(int i,int j)&#123;</span><br><span class="line">    if(i&#x3D;&#x3D;n)&#123;</span><br><span class="line">      return D[i,j];</span><br><span class="line">    &#125;</span><br><span class="line">    return max(MaxSum[i+1,j],MaxSum[i+1,j+1)+D[i,j];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;i;j++)&#123;</span><br><span class="line">        cin &gt;&gt;D[i,j&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   cout&lt;&lt;MaxSum[1,1]&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>但是，这样计算的时间复杂度非常高，因为我们重复计算了很多次已经计算过的值。</p>
<p><img src="http://img.blog.csdn.net/20150811140840233?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="三角形计算值"><br><strong>例如</strong>：计算MaxSum[2,1]时，会计算MaxSum[3,2];当计算MaxSum[2,2]时，又会计算MaxSum[3,2]。这样就会重复很多次无用计算。<br>所以可以改进程序，使之成为 <em>记忆型递归算法</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;Math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int D[101][101];</span><br><span class="line">int n;</span><br><span class="line">int MaxSum(int i,int j)&#123;</span><br><span class="line">    if(MaxSum[i,j]!&#x3D;-1)&#123;</span><br><span class="line">      return MaxSum[i,j];</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&#x3D;&#x3D;n)&#123;</span><br><span class="line">      return D[i,j];</span><br><span class="line">    &#125;</span><br><span class="line">    return max(MaxSum[i+1,j],MaxSum[i+1,j+1)+D[i,j];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;i;j++)&#123;</span><br><span class="line">        cin &gt;&gt;D[i,j&#125;;</span><br><span class="line">        MaxSum[i,j]&#x3D;-1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;MaxSum[1,1]&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>因为递归要使用大量堆栈空间，容易造成栈溢出，所以考虑把递归改为递推。<br>从最后一行开始计算，因为最后一行的值可以直接得到：<br><img src="http://img.blog.csdn.net/20150811152746815?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>然后倒数第二行，从左侧第一个数开始，将其与下方左右两个数分别相加，选择最大的填入空格。<br><img src="http://img.blog.csdn.net/20150811153237686?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>依次计算每行的值<br><img src="http://img.blog.csdn.net/20150811153534629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><img src="http://img.blog.csdn.net/20150811153553012?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>由此，便从递归型动态规划=&gt;递推型动态规划：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int D[101][101];</span><br><span class="line">int MaxSum[101][101];</span><br><span class="line">int n;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;i;j++)&#123;</span><br><span class="line">            cin&gt;&gt;D[i,j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;</span><br><span class="line">        MaxSum[n][i] &#x3D; D[n][i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;n-1;i&gt;&#x3D;1;i--)&#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;i,;j++)&#123;</span><br><span class="line">            MaxSum[i][j]&#x3D;max(MaxSum[i+1][j],MaxSum[i+1][j+1])+D[i][j];</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     cout&lt;&lt;MaxSum[1][1]&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p>接下来对空间进行优化，可以不采用二维数组来存储MaxSum[i][j],只要采用一维数组MaxSum[101]，一层一层向外推就可以了。<br>对空间优化后的递推过程如下：<br><img src="http://img.blog.csdn.net/20150811155011262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><img src="http://img.blog.csdn.net/20150811155028144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><img src="http://img.blog.csdn.net/20150811155119121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><img src="http://img.blog.csdn.net/20150811155136507?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><img src="http://img.blog.csdn.net/20150811155255355?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br><img src="http://img.blog.csdn.net/20150811155311499?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>maxSum数组都可以不要，直接用D的第n行直接替代maxSum即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;algorithm&gt; </span><br><span class="line">using namespace std; </span><br><span class="line"></span><br><span class="line">#define MAX 101  </span><br><span class="line"></span><br><span class="line">int D[MAX][MAX];  </span><br><span class="line">int n; </span><br><span class="line">int * maxSum; </span><br><span class="line"></span><br><span class="line">int main()&#123;    </span><br><span class="line">	int i,j;    </span><br><span class="line">	cin &gt;&gt; n;    </span><br><span class="line">	for(i&#x3D;1;i&lt;&#x3D;n;i++)   </span><br><span class="line">		for(j&#x3D;1;j&lt;&#x3D;i;j++)        </span><br><span class="line">			cin &gt;&gt; D[i][j];   </span><br><span class="line">	maxSum &#x3D; D[n]; &#x2F;&#x2F;maxSum指向第n行    </span><br><span class="line">	for( int i &#x3D; n-1; i&gt;&#x3D; 1;  --i )     </span><br><span class="line">		for( int j &#x3D; 1; j &lt;&#x3D; i; ++j )       </span><br><span class="line">			maxSum[j] &#x3D; max(maxSum[j],maxSum[j+1]) + D[i][j];    </span><br><span class="line">	cout &lt;&lt; maxSum[1] &lt;&lt; endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态规划适用情况"><a href="#动态规划适用情况" class="headerlink" title="动态规划适用情况"></a>动态规划适用情况</h3><p>一般具有三个性质：</p>
<ol>
<li><strong>最优化原理</strong>：问题的最优解所包含的子问题的解也是最优的，称该问题具有最优子结构。</li>
<li><strong>无后效性</strong>：某阶段状态一旦确定，就不受这个状态以后的决策的影响。</li>
<li><strong>有重叠子问题</strong>：子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用。（不是必要条件）。</li>
</ol>
<h3 id="求解的基本步骤"><a href="#求解的基本步骤" class="headerlink" title="求解的基本步骤"></a>求解的基本步骤</h3><ol>
<li><em>化分阶段</em>：化分后的阶段一定要是有序的或者是可排序的。</li>
<li><em>确定状态和状态变量</em>：将问题发展到各个阶段时所处的各种客观情况用不同的状态表示出来。</li>
<li><em>确定决策并写出状态转移方程</em>：状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。</li>
<li><em>寻找边界条件</em>：状态转移方程是一个递推式，需要递推的终止条件。</li>
</ol>
<p>f(n,m)=max{f(n-1.m),f(n-1,m-w[n])+P(n,m)};</p>
<hr>
<p>最后提供一个非常全面的动态规划讲解：<br>作者：Hawstein<br>出处：<a href="">http://www.hawstein.com/posts/dp-novice-to-advanced.html</a><br>声明：本文采用以下协议进行授权： 自由转载-非商用-非衍生-保持署名|Creative Commons BY-NC-ND 3.0 ，转载请注明作者及出处。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/07/2017-03-07-%E7%94%9F%E6%88%90%E5%AD%97%E5%85%B8%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doreen">
      <meta itemprop="description" content="this  is a personal recordings for study & life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Doreen's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/07/2017-03-07-%E7%94%9F%E6%88%90%E5%AD%97%E5%85%B8%E5%BA%8F/" class="post-title-link" itemprop="url">Next Permutation</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-03-07 00:00:00" itemprop="dateCreated datePublished" datetime="2017-03-07T00:00:00+08:00">2017-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-04 16:47:10" itemprop="dateModified" datetime="2022-05-04T16:47:10+08:00">2022-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="下一个字典序-Next-Permutation"><a href="#下一个字典序-Next-Permutation" class="headerlink" title="下一个字典序 Next Permutation"></a>下一个字典序 Next Permutation</h2><h3 id="leetcode-31"><a href="#leetcode-31" class="headerlink" title="leetcode 31"></a>leetcode 31</h3><p>题目描述：Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.<br>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).<br>The replacement must be in-place, do not allocate extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.<br>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
<hr>
<h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>交换+逆序</p>
<ol>
<li>从后向前遍历直到遇到第一对正序对，num[i]&gt;num[i+1];</li>
<li>从后向前遍历找到第一个大于num[i]的数字，num[i]&lt;num[j];</li>
<li>交换num[i]和num[j];</li>
<li>将num[i+1]~num[length-1]逆序排列<h3 id="代码（js）"><a href="#代码（js）" class="headerlink" title="代码（js）"></a>代码（js）</h3></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nextPermutation = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len=nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*第一个正序对的i值*/</span></span><br><span class="line">    <span class="keyword">var</span> cur=<span class="number">-1</span>;   </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=len<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            cur=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*若不存在，则重新最小排序*/</span></span><br><span class="line">    <span class="keyword">if</span>(cur===<span class="number">-1</span>)&#123;</span><br><span class="line">        nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-b;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="comment">/*存在则从后向前遍历找到第一个j使得num[j]&gt;num[cur]*/</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> greater;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=len<span class="number">-1</span>;j&gt;cur;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;nums[cur])&#123;</span><br><span class="line">                greater=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*交换num[i]和num[j]*/</span></span><br><span class="line">        <span class="keyword">var</span> tmp=nums[greater];</span><br><span class="line">        nums[greater]=nums[cur];</span><br><span class="line">        nums[cur]=tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*逆序num[i+1]~num[len-1]*/</span></span><br><span class="line">        <span class="keyword">var</span> num= nums.splice(cur+<span class="number">1</span>,len-cur<span class="number">-1</span>);</span><br><span class="line">        num.reverse();</span><br><span class="line">        <span class="built_in">Array</span>.prototype.push.apply(nums,num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>将数组num[i+1]~num[length-1]逆序排列，因为本题无返回值，所以只能在原有数组上进行操作，开始的方法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = nums.splice(cur+<span class="number">1</span>,len-cur<span class="number">-1</span>);</span><br><span class="line">num.reverse();</span><br><span class="line">nums = nums.concat(num);</span><br></pre></td></tr></table></figure>

<p>但是提交之后发现concat函数无效，因此改用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.push.apply(nums,num)</span><br></pre></td></tr></table></figure>

<p>因为向数组添加数组所以不能直接用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums.push()</span><br></pre></td></tr></table></figure>

<h3 id="延伸—全排列算法"><a href="#延伸—全排列算法" class="headerlink" title="延伸—全排列算法"></a>延伸—全排列算法</h3><h4 id="全排列就是从最小字典序排列到最大字典序的过程"><a href="#全排列就是从最小字典序排列到最大字典序的过程" class="headerlink" title="全排列就是从最小字典序排列到最大字典序的过程"></a>全排列就是从最小字典序排列到最大字典序的过程</h4><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><ol>
<li>对给定的序列作升序排列，得到最小字典序</li>
<li>对有序排列求下一个字典序</li>
<li>若当前排序没有下一个字典序，即已经得到最大字典序，全排列结束。</li>
</ol>
<p>当然还有很多其他全排列算法，例如递归：<br>当n=1时，perm（R）=（r），其中r是集合R中唯一元素。<br>当n&gt;1时，perm（R）由（r1）perm（R1），（r2）perm（R2），….，（rn）perm（Rn）构成。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/06/2017-03-06-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Doreen">
      <meta itemprop="description" content="this  is a personal recordings for study & life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Doreen's Notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/06/2017-03-06-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">front-end--面试题整理</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-03-06 00:00:00" itemprop="dateCreated datePublished" datetime="2017-03-06T00:00:00+08:00">2017-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-04 16:47:10" itemprop="dateModified" datetime="2022-05-04T16:47:10+08:00">2022-05-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/FE/" itemprop="url" rel="index"><span itemprop="name">FE</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Doctype作用？标准模式与兼容模式各有什么区别"><a href="#Doctype作用？标准模式与兼容模式各有什么区别" class="headerlink" title="Doctype作用？标准模式与兼容模式各有什么区别?"></a>Doctype作用？标准模式与兼容模式各有什么区别?</h3><p>（1）、&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 <html> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。</p>
<p>（2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。<br>HTML5 为什么只需要写 <!DOCTYPE HTML>？</p>
<p> HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）；</p>
<p> 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/03/06/2017-03-06-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Doreen</p>
  <div class="site-description" itemprop="description">this  is a personal recordings for study & life</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Doreen</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.7.2
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/assets/hijiki.model.json"},"display":{"superSample":2,"width":165,"height":155,"position":"right","vOffset":-20},"mobile":{"show":false,"scale":0.05},"react":{"opacityDefault":1,"opacityOnHover":0.2},"log":false});</script></body>
</html>
